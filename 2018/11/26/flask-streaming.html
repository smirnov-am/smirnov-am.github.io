<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Streaming timeseries with Flask and Plotly | Alexey Smirnov</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="Streaming timeseries with Flask and Plotly" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This simple app for streaming cpu utilization to a web page. I’m using Flask as websockets server (flask-socketio plugin), socket.io as client library and plotly.js for visualization." />
<meta property="og:description" content="This simple app for streaming cpu utilization to a web page. I’m using Flask as websockets server (flask-socketio plugin), socket.io as client library and plotly.js for visualization." />
<link rel="canonical" href="http://localhost:4000/2018/11/26/flask-streaming.html" />
<meta property="og:url" content="http://localhost:4000/2018/11/26/flask-streaming.html" />
<meta property="og:site_name" content="Alexey Smirnov" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-11-26T00:00:00+01:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2018/11/26/flask-streaming.html","description":"This simple app for streaming cpu utilization to a web page. I’m using Flask as websockets server (flask-socketio plugin), socket.io as client library and plotly.js for visualization.","headline":"Streaming timeseries with Flask and Plotly","datePublished":"2018-11-26T00:00:00+01:00","dateModified":"2018-11-26T00:00:00+01:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2018/11/26/flask-streaming.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Alexey Smirnov" /></head>
<body><header class="site-header" role="banner">

    <div class="wrapper"><a class="site-title" rel="author" href="/">Alexey Smirnov</a><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger" />
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewBox="0 0 18 15" width="18px" height="15px">
                <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
                <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
                <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
              </svg>
            </span>
          </label>
  
        <div class="trigger">
          <a class="page-link" href="https://www.linkedin.com/in/smirnovam/">Linkedin</a>
          <a class="page-link" href="https://github.com/smirnov-am">GitHub</a>
        </div>
        </nav></div>
  </header><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Streaming timeseries with Flask and Plotly</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-11-26T00:00:00+01:00" itemprop="datePublished">Nov 26, 2018
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>This simple app for streaming cpu utilization to a web page.
I’m using Flask as websockets server (flask-socketio plugin),
socket.io as client library and plotly.js
for visualization.</p>

<p><img src="https://github.com/smirnov-am/flask-streaming/blob/master/demo.gif?raw=true" alt="demo" /></p>

<h2 id="flask-app">Flask app</h2>
<p>I’m following a flask-socketio <a href="https://flask-socketio.readthedocs.io/en/latest/">doc</a>
to create a flask app. SocketIO is going to use Redis as message broker as there will be
a separate process that pushes messages to clients. Flask websocket server and this process
will communicate through Redis.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">create_app</span><span class="p">(</span><span class="n">register_blueprint</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">secret_key</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">urandom</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">register_blueprint</span><span class="p">:</span>
        <span class="n">app</span><span class="o">.</span><span class="n">register_blueprint</span><span class="p">(</span><span class="n">plotting_blueprint</span><span class="p">)</span>

    <span class="n">socketio</span> <span class="o">=</span> <span class="n">SocketIO</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">message_queue</span><span class="o">=</span><span class="s">'redis://localhost:6379/'</span><span class="p">)</span>
    <span class="n">socketio</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s">'connect'</span><span class="p">,</span> <span class="n">bootstrap_on_connect</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">socketio</span><span class="p">,</span> <span class="n">app</span>


<span class="n">socketio</span><span class="p">,</span> <span class="n">application</span> <span class="o">=</span> <span class="n">create_app</span><span class="p">()</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">socketio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">application</span><span class="p">)</span>
</code></pre></div></div>

<p>Here I’m defining first hook - when client connects we are going to send him
some history data - the task for <code class="highlighter-rouge">bootstrap_on_connect</code> functions.</p>

<p>The blueprint I’m defining is simple one that has only one route that serves a static page.
This page will load client’s javascript. The only parameter is window size - I’d like to see only
last 100 seconds of data.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Blueprint</span><span class="p">,</span> <span class="n">render_template</span>

<span class="n">plotting_blueprint</span> <span class="o">=</span> <span class="n">Blueprint</span><span class="p">(</span><span class="s">'plotting'</span><span class="p">,</span> <span class="n">__name__</span><span class="p">)</span>


<span class="nd">@plotting_blueprint.route</span><span class="p">(</span><span class="s">'/'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">'index.html'</span><span class="p">,</span> <span class="n">x_window</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

</code></pre></div></div>

<h2 id="template-and-client-code">Template and client code</h2>
<p>In the template I’m putting window size inside meta tag so JS will be able to read that.
Also I’m loading all libraries in the end of body</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"UTF-8"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">name=</span><span class="s">"x_window"</span> <span class="na">content=</span><span class="s">{{x_window}}</span><span class="nt">&gt;</span>
    <span class="nt">&lt;title&gt;</span>Flask data viz<span class="nt">&lt;/title&gt;</span>
    <span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">type=</span><span class="s">"text/css"</span> <span class="na">href=</span><span class="s">"{{ url_for('static', filename='styles.css') }}"</span><span class="nt">&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
<span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"plot"</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"https://cdn.plot.ly/plotly-latest.min.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"text/javascript"</span> <span class="na">src=</span><span class="s">"//cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.6/socket.io.min.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"{{ url_for('static', filename='plot.js') }}"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>

</code></pre></div></div>

<p><code class="highlighter-rouge">plot.js</code> will contain all client-side logic.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="s1">'http://'</span> <span class="o">+</span> <span class="nb">document</span><span class="p">.</span><span class="nx">domain</span> <span class="o">+</span> <span class="s1">':'</span> <span class="o">+</span> <span class="nx">location</span><span class="p">.</span><span class="nx">port</span>
<span class="kd">var</span> <span class="nx">socket</span> <span class="o">=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">connect</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>

<span class="nx">socket</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'connect'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'connected to websocket on '</span> <span class="o">+</span> <span class="nx">url</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">socket</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'bootstrap'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">plot_start</span> <span class="o">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="nx">makePlotly</span><span class="p">(</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">y</span> <span class="p">)</span>
<span class="p">});</span>

<span class="nx">socket</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'update'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">streamPlotly</span><span class="p">(</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">y</span> <span class="p">)</span>
<span class="p">});</span>
</code></pre></div></div>
<p>First we connect to websocket (using HTTP, not WS protocol).
When connected Flask will send us <code class="highlighter-rouge">bootstrap</code> message with initial data.
Here <code class="highlighter-rouge">makePlotly</code> function is invoked. It will initialize plotly stuff.
When <code class="highlighter-rouge">update</code> message is received <code class="highlighter-rouge">streamPlotly</code> will use <code class="highlighter-rouge">Plotly.extendTraces</code>
to add data to plotly traces. It also updates the layout so we’ll have nice sliding window.</p>

<h2 id="running-the-app">Running the app</h2>
<p>To run the app I’m using uwsgi with gevent. uwsgi config:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[uwsgi]
module = app:application
uid = www-data

http = 127.0.0.1:5000

gevent-monkey-patch = true
http-websockets = true
gevent = 1000

</code></pre></div></div>

<p>Protocol for websockets is going to be HTTP so uwsgi will listen on port 5000
instead of communication through UNIX socket with nginx.</p>

<p>Nginx config should create a separate location for websocket url</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">server</span> <span class="p">{</span>
    <span class="kn">listen</span>       <span class="mi">80</span> <span class="s">default_server</span><span class="p">;</span>
    <span class="kn">listen</span>       <span class="s">[::]:80</span> <span class="s">default_server</span><span class="p">;</span>
    <span class="kn">server_name</span>  <span class="s">localhost</span><span class="p">;</span>
    <span class="kn">root</span>         <span class="n">/var/www/html</span><span class="p">;</span>
    <span class="kn">client_max_body_size</span> <span class="mi">16M</span><span class="p">;</span>

    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">include</span> <span class="s">proxy_params</span><span class="p">;</span>
        <span class="kn">proxy_pass</span> <span class="s">http://127.0.0.1:5000</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kn">location</span> <span class="n">/socket.io</span> <span class="p">{</span>
        <span class="kn">include</span> <span class="s">proxy_params</span><span class="p">;</span>
        <span class="kn">proxy_http_version</span> <span class="mi">1</span><span class="s">.1</span><span class="p">;</span>
        <span class="kn">proxy_set_header</span> <span class="s">Upgrade</span> <span class="nv">$http_upgrade</span><span class="p">;</span>
        <span class="kn">proxy_set_header</span> <span class="s">Connection</span> <span class="s">"Upgrade"</span><span class="p">;</span>
        <span class="kn">proxy_set_header</span> <span class="s">Host</span> <span class="nv">$host</span><span class="p">;</span>
        <span class="kn">proxy_pass</span> <span class="s">http://127.0.0.1:5000/socket.io</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="background-job">Background job</h3>
<p>A separate process gets CPU utilization with <code class="highlighter-rouge">psutil</code> and pushes message to clients.
Also it defines bootstrap function - but I’m just starting with empty lists for now.</p>

<p><code class="highlighter-rouge">streaming.py</code>:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/env python</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">psutil</span> <span class="kn">import</span> <span class="n">cpu_percent</span>
<span class="kn">from</span> <span class="nn">flask_socketio</span> <span class="kn">import</span> <span class="n">emit</span><span class="p">,</span> <span class="n">SocketIO</span>

<span class="n">DATE_FMT</span> <span class="o">=</span> <span class="s">"</span><span class="si">%</span><span class="s">Y-</span><span class="si">%</span><span class="s">m-</span><span class="si">%</span><span class="s">d </span><span class="si">%</span><span class="s">H:</span><span class="si">%</span><span class="s">M:</span><span class="si">%</span><span class="s">S"</span>


<span class="k">def</span> <span class="nf">bootstrap_on_connect</span><span class="p">():</span>
    <span class="n">emit</span><span class="p">(</span><span class="s">'bootstrap'</span><span class="p">,</span> <span class="p">{</span><span class="s">'x'</span><span class="p">:</span> <span class="p">[</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">DATE_FMT</span><span class="p">)],</span> <span class="s">'y'</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]})</span>


<span class="k">def</span> <span class="nf">update_plot</span><span class="p">():</span>
    <span class="n">socketio</span> <span class="o">=</span> <span class="n">SocketIO</span><span class="p">(</span><span class="n">message_queue</span><span class="o">=</span><span class="s">'redis://localhost:6379/'</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">datetime_now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">DATE_FMT</span><span class="p">)</span>
        <span class="n">cpu_percent_second</span> <span class="o">=</span> <span class="n">cpu_percent</span><span class="p">(</span><span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">socketio</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="s">'update'</span><span class="p">,</span> <span class="p">{</span><span class="s">'x'</span><span class="p">:</span> <span class="p">[</span><span class="n">datetime_now</span><span class="p">],</span> <span class="s">'y'</span><span class="p">:</span> <span class="p">[</span><span class="n">cpu_percent_second</span><span class="p">]})</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">update_plot</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="running-it-all">Running it all</h2>

<ol>
  <li>Install redis server and nginx</li>
  <li>Run uwsgi with <code class="highlighter-rouge">uwsgi --ini uwsgi.ini</code></li>
  <li>Install all dependencies from requirements.txt into virtual environment</li>
  <li>Run streaming.py (<code class="highlighter-rouge">chmod +x streaming.py &amp;&amp; ./streaming.py</code>)</li>
</ol>

<h2 id="further-thoughts">Further thoughts</h2>
<p>There is not persistence to the data and newly connected client won’t be able to
see the history. For the some kind on storage is needed. Another approach
is to periodically call Flask from javascript to get the data though AJAX call.
I find a websocket solution more interesting - but more complex - because it allows
to have a separate process to update clients, that offloads some work from web server.</p>

<p>Full code is available from this <a href="https://github.com/smirnov-am/flask-streaming">repo</a></p>

<p>Do you use websockets for streaming live data? Connect with me on
<a href="https://www.linkedin.com/in/smirnovam/">linkedin</a> to discuss it.</p>

  </div><a class="u-url" href="/2018/11/26/flask-streaming.html" hidden></a>
</article>

      </div>
    </main></body>

</html>
