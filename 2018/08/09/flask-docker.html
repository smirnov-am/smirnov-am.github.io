<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Running Flask in production with Docker | Alexey Smirnov</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="Running Flask in production with Docker" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Google top for running Flask with Docker is full of posts where Flask runs in debug mode. That what logs look like when Flask is in developement mode:" />
<meta property="og:description" content="Google top for running Flask with Docker is full of posts where Flask runs in debug mode. That what logs look like when Flask is in developement mode:" />
<link rel="canonical" href="http://localhost:4000/2018/08/09/flask-docker.html" />
<meta property="og:url" content="http://localhost:4000/2018/08/09/flask-docker.html" />
<meta property="og:site_name" content="Alexey Smirnov" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-09T00:00:00+02:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2018/08/09/flask-docker.html","description":"Google top for running Flask with Docker is full of posts where Flask runs in debug mode. That what logs look like when Flask is in developement mode:","headline":"Running Flask in production with Docker","datePublished":"2018-08-09T00:00:00+02:00","dateModified":"2018-08-09T00:00:00+02:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2018/08/09/flask-docker.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Alexey Smirnov" /></head>
<body><header class="site-header" role="banner">

    <div class="wrapper"><a class="site-title" rel="author" href="/">Alexey Smirnov</a><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger" />
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewBox="0 0 18 15" width="18px" height="15px">
                <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
                <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
                <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
              </svg>
            </span>
          </label>
  
        <div class="trigger">
          <a class="page-link" href="https://www.linkedin.com/in/smirnovam/">Linkedin</a>
          <a class="page-link" href="https://github.com/smirnov-am">GitHub</a>
          <a class="page-link" href="https://tinyletter.com/smirnov-am">Newsletter</a>
        </div>
        </nav></div>
  </header><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Running Flask in production with Docker</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-08-09T00:00:00+02:00" itemprop="datePublished">Aug 9, 2018
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Google top for running Flask with Docker is full of posts where Flask runs in debug mode.
That what logs look like when Flask is in developement mode:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> * Serving Flask app "app" (lazy loading)
 * Environment: production
   WARNING: Do not use the development server in a production environment.
   Use a production WSGI server instead.
 * Debug mode: on
 * Running on http://0.0.0.0:5555/ (Press CTRL+C to quit)
</code></pre></div></div>

<p>I’d like to make a tutorial on how to run it with uwsgi in Docker using common Docker images.</p>

<h2 id="flask-app">Flask app</h2>
<p>I’ll take a basic Flask app from it’s official <a href="http://flask.pocoo.org/">docs</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">"/"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">"Hello World!"</span>
</code></pre></div></div>

<p>Naming this file as <code class="highlighter-rouge">hello.py</code> and running it with <code class="highlighter-rouge">FLASK_APP=test.py flask run --port 5555</code> will yield a warning that development server is used in a production environment like above.</p>

<h2 id="uwsgi">uwsgi</h2>
<p>As suggested by the warning we should use <code class="highlighter-rouge">uwsgi</code> to run it. For that to happen let’s create a uwsgi configuration file named <code class="highlighter-rouge">uwsgi.ini</code></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>uwsgi]
module <span class="o">=</span> hello:app
uid <span class="o">=</span> www-data
gid <span class="o">=</span> www-data
master <span class="o">=</span> <span class="nb">true
</span>processes <span class="o">=</span> 5

socket <span class="o">=</span> /tmp/uwsgi.socket
chmod-sock <span class="o">=</span> 664
vacuum <span class="o">=</span> <span class="nb">true

</span>die-on-term <span class="o">=</span> <span class="nb">true</span>
</code></pre></div></div>

<p>So running uwsgi app with <code class="highlighter-rouge">uwsgi --ini uwsgi.ini </code> will give long output indicating that uwsgi started 5 processes (see <code class="highlighter-rouge">processes=5</code> in the config). Development server runs only 1 process thus allowing only 1 request at a time. By increasing this number you will increase the number if simultaneous requests to Flask app, but that will require more RAM and there will be more processes with Python interpreter running.</p>

<p>There is also a backlog for uwsgi meaning that if all workers (uwsgi processes) are buy with requests, excessive requests will be put in a queue of size 100 by default. Requests above that level will be dropped by uwsgi, but we will eventually have nginx in front of it with it’s own backlog.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>uWSGI] getting INI configuration from uwsgi.ini                                             
<span class="k">***</span> Starting uWSGI 2.0.17.1 <span class="o">(</span>64bit<span class="o">)</span> on <span class="o">[</span>Fri Aug  3 22:29:18 2018] <span class="k">***</span>                        
compiled with version: 7.2.0 on 03 August 2018 22:23:17                                      
os: Linux-4.13.0-46-generic <span class="c">#51-Ubuntu SMP Tue Jun 12 12:36:29 UTC 2018                      </span>
nodename: ubuntuvm                                                                                                                                                                           
machine: x86_64                                                                              
clock <span class="nb">source</span>: unix                            
detected number of CPU cores: 4               
current working directory: /home/as/Desktop/blog                                    
detected binary path: /home/as/.virtualenvs/blog/bin/uwsgi                          
<span class="o">!!!</span> no internal routing support, rebuild with pcre support <span class="o">!!!</span>                               
your processes number limit is 63569          
your memory page size is 4096 bytes  
detected max file descriptor number: 1024     
lock engine: pthread robust mutexes                                                          
thunder lock: disabled <span class="o">(</span>you can <span class="nb">enable </span>it with <span class="nt">--thunder-lock</span><span class="o">)</span>                               
uwsgi socket 0 bound to UNIX address /tmp/uwsgi.socket fd 3                                  
Python version: 3.6.3 <span class="o">(</span>default, Oct  3 2017, 21:45:48<span class="o">)</span>  <span class="o">[</span>GCC 7.2.0]                          
<span class="k">***</span> Python threads support is disabled. You can <span class="nb">enable </span>it with <span class="nt">--enable-threads</span> <span class="k">***</span>          
Python main interpreter initialized at 0x562fb447cb40        i     i         i               
your server socket listen backlog is limited to 100 connections                              
your mercy <span class="k">for </span>graceful operations on workers is 60 seconds                                  
mapped 437520 bytes <span class="o">(</span>427 KB<span class="o">)</span> <span class="k">for </span>5 cores                                                     
<span class="k">***</span> Operational MODE: preforking <span class="k">***</span>                                                         
WSGI app 0 <span class="o">(</span><span class="nv">mountpoint</span><span class="o">=</span><span class="s1">''</span><span class="o">)</span> ready <span class="k">in </span>1 seconds on interpreter 0x562fb447cb40 pid: 23917 <span class="o">(</span>default app<span class="o">)</span>                                                                                       
<span class="k">***</span> uWSGI is running <span class="k">in </span>multiple interpreter mode <span class="k">***</span>                                        
spawned uWSGI master process <span class="o">(</span>pid: 23917<span class="o">)</span>     
spawned uWSGI worker 1 <span class="o">(</span>pid: 23923, cores: 1<span class="o">)</span> 
spawned uWSGI worker 2 <span class="o">(</span>pid: 23924, cores: 1<span class="o">)</span>                     
spawned uWSGI worker 3 <span class="o">(</span>pid: 23925, cores: 1<span class="o">)</span>                     
spawned uWSGI worker 4 <span class="o">(</span>pid: 23926, cores: 1<span class="o">)</span>                     
spawned uWSGI worker 5 <span class="o">(</span>pid: 23927, cores: 1<span class="o">)</span> 
</code></pre></div></div>

<p>Also this will create a socket file, that will be referred later in nginx configuration.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~ <span class="nb">ls</span> <span class="nt">-la</span> /tmp/uwsgi.socket  
srwxrwxr-x 1 as as 0 aug  3 22:29 /tmp/uwsgi.socket
</code></pre></div></div>
<p>Another thing is the user which runs <code class="highlighter-rouge">uwsgi</code> processes and owns a socket. Ideally you need to use user with minimum access right. With <code class="highlighter-rouge">uid</code>/<code class="highlighter-rouge">gid</code> options I’ve specified <code class="highlighter-rouge">www-data</code> - standard user used by web servers. If you run uwsgi manually from bash it will use your user for socket and processes. But in Docker we will run it as root so these options are needed to downgrade it to <code class="highlighter-rouge">www-data</code>.</p>

<p>Also I’ve seen that some distributions clean /tmp or some daemons have different view but it’s not the case with the base distribution for the image I’m using.</p>

<p>Uwsgi has a lot of configuration options. There is a good list you need to check if you need to troubleshoot/tune your application that can be found <a href="https://uwsgi-docs.readthedocs.io/en/latest/ThingsToKnow.html">here</a></p>

<h2 id="nginx">nginx</h2>
<p>Nginx will serve as a proxy to uwsgi. It’s nginx that will listen on ports 80/443 and forward requests to the socket.
It’s config (named <code class="highlighter-rouge">nginx.conf</code>) is pretty straightforward (I’m omitting SSL config)</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">user</span> <span class="s">www-data</span><span class="p">;</span>
<span class="k">worker_processes</span> <span class="s">auto</span><span class="p">;</span>
<span class="k">pid</span> <span class="n">/run/nginx.pid</span><span class="p">;</span>

<span class="k">events</span> <span class="p">{</span>
    <span class="kn">worker_connections</span> <span class="mi">1024</span><span class="p">;</span>
    <span class="kn">use</span> <span class="s">epoll</span><span class="p">;</span>
    <span class="kn">multi_accept</span> <span class="no">on</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">http</span> <span class="p">{</span>
    <span class="kn">access_log</span> <span class="n">/dev/stdout</span><span class="p">;</span>
    <span class="kn">error_log</span> <span class="n">/dev/stdout</span><span class="p">;</span>

    <span class="kn">sendfile</span>            <span class="no">on</span><span class="p">;</span>
    <span class="kn">tcp_nopush</span>          <span class="no">on</span><span class="p">;</span>
    <span class="kn">tcp_nodelay</span>         <span class="no">on</span><span class="p">;</span>
    <span class="kn">keepalive_timeout</span>   <span class="mi">65</span><span class="p">;</span>
    <span class="kn">types_hash_max_size</span> <span class="mi">2048</span><span class="p">;</span>

    <span class="kn">include</span>             <span class="n">/etc/nginx/mime.types</span><span class="p">;</span>
    <span class="kn">default_type</span>        <span class="nc">application/octet-stream</span><span class="p">;</span>

    <span class="kn">index</span>   <span class="s">index.html</span> <span class="s">index.htm</span><span class="p">;</span>

    <span class="kn">server</span> <span class="p">{</span>
        <span class="kn">listen</span>       <span class="mi">80</span> <span class="s">default_server</span><span class="p">;</span>
        <span class="kn">listen</span>       <span class="s">[::]:80</span> <span class="s">default_server</span><span class="p">;</span>
        <span class="kn">server_name</span>  <span class="s">localhost</span><span class="p">;</span>
        <span class="kn">root</span>         <span class="n">/var/www/html</span><span class="p">;</span>

        <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
            <span class="kn">include</span> <span class="s">uwsgi_params</span><span class="p">;</span>
            <span class="kn">uwsgi_pass</span> <span class="s">unix:/tmp/uwsgi.socket</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I’ve added redirection of access and error logs to stdout so both will be accessible through <code class="highlighter-rouge">docker logs</code> command. Uwsgi logs are streamed to stdout by default.</p>

<p>One interesting thing I found is about long lasting requests. Nginx itself may kill these requests. So it’s worth adding this config to <code class="highlighter-rouge">location</code> block:</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">uwsgi_read_timeout</span> <span class="s">1h</span><span class="p">;</span>
<span class="k">uwsgi_send_timeout</span> <span class="s">1h</span><span class="p">;</span>
<span class="k">proxy_send_timeout</span> <span class="s">1h</span><span class="p">;</span>
<span class="k">proxy_read_timeout</span> <span class="s">1h</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="startup-script">Startup script</h2>
<p>This is a simple startup stript that will be used as default for executing container.
Name of the file will be <code class="highlighter-rouge">start.sh</code> and it will be referred in Dockerfile.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/env bash</span>
service nginx start
uwsgi <span class="nt">--ini</span> uwsgi.ini
</code></pre></div></div>

<h2 id="requirements">requirements</h2>
<p>Requirements file (<code class="highlighter-rouge">requirements.txt</code>) will have only flask and uwsgi and will look like this:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">click</span><span class="o">==</span>6.7
<span class="nv">Flask</span><span class="o">==</span>1.0.2
<span class="nv">itsdangerous</span><span class="o">==</span>0.24
<span class="nv">Jinja2</span><span class="o">==</span>2.10
<span class="nv">MarkupSafe</span><span class="o">==</span>1.0
<span class="nv">uWSGI</span><span class="o">==</span>2.0.17.1
<span class="nv">Werkzeug</span><span class="o">==</span>0.14.1
</code></pre></div></div>

<h2 id="dockerfile">Dockerfile</h2>
<p>I’ve tried a couple of ready-made images from Docker hub and found them overcomplicated or edited in a way by their maintainers making them unusable. So I’ll start with basic python image.</p>

<div class="language-docker highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> python:3.6-slim</span>
</code></pre></div></div>

<p>First thing let’s copy <code class="highlighter-rouge">hello.py</code>, <code class="highlighter-rouge">uwsgi.ini</code>, <code class="highlighter-rouge">requirements.txt</code> and <code class="highlighter-rouge">start.sh</code> to working directory:</p>

<div class="language-docker highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">COPY</span><span class="s"> . /srv/flask_app</span>
<span class="k">WORKDIR</span><span class="s"> /srv/flask_app</span>
</code></pre></div></div>

<p>Base image doesn’t have nginx and some useful packages</p>

<div class="language-docker highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">RUN </span>apt-get clean <span class="se">\
</span>    <span class="o">&amp;&amp;</span> apt-get <span class="nt">-y</span> update

<span class="k">RUN </span>apt-get <span class="nt">-y</span> <span class="nb">install </span>nginx <span class="se">\
</span>    <span class="o">&amp;&amp;</span> apt-get <span class="nt">-y</span> <span class="nb">install </span>python3-dev <span class="se">\
</span>    <span class="o">&amp;&amp;</span> apt-get <span class="nt">-y</span> <span class="nb">install </span>build-essential
</code></pre></div></div>

<p>Now let’s install python requirements</p>

<div class="language-docker highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">RUN </span>pip <span class="nb">install</span> <span class="nt">-r</span> requirements.txt <span class="nt">--src</span> /usr/local/src
</code></pre></div></div>

<p>Finally, copy nginx config to the proper location, add execution rights to startup script and set is as default.</p>

<div class="language-docker highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">COPY</span><span class="s"> nginx.conf /etc/nginx</span>
<span class="k">RUN </span><span class="nb">chmod</span> +x ./start.sh
<span class="k">CMD</span><span class="s"> ["./start.sh"]</span>
</code></pre></div></div>

<h2 id="building-and-running">Building and running</h2>

<p>Image build can be done like so:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nb">.</span> <span class="nt">-t</span> flask_image
</code></pre></div></div>
<p>It creates an image named <code class="highlighter-rouge">flask_image</code> that can be run with this command:</p>

<p><code class="highlighter-rouge">docker run  --name flask_container -p 80:80 flask_image</code></p>

<p>Now you may navigate to http://localhost in you browser to see the output.</p>

<p>Some usefull options when runnign container</p>
<ul>
  <li><code class="highlighter-rouge">--name</code> gives the container a name that can be found in <code class="highlighter-rouge">docker ps</code> output</li>
  <li><code class="highlighter-rouge">-p</code> instructs to publish port 80. Second 80 after semicolons tells what port nginx inside the container listens on</li>
  <li><code class="highlighter-rouge">-d</code> runs container detached from terminal. Logs then can be viewed by issuing <code class="highlighter-rouge">docker logs</code> command</li>
</ul>

<h2 id="advantages-of-dockerized-flask">Advantages of dockerized Flask</h2>
<p>I found it very useful to run Flask like that for a number of reasons:</p>

<p>1) Portability: spinning projects on a different machine with different distribution is a piece of cake, provided docker is installed.</p>

<p>2) No need to configure process managers (upstart/systemd)</p>

<p>3) Automatic restart of failed containers. Just use <code class="highlighter-rouge">--restart on-failure</code> with <code class="highlighter-rouge">docker run</code></p>

<p>4) It’s very easy to start with almost serverless AWS ECS Fargate.</p>

<h2 id="toubleshooting">Toubleshooting</h2>
<p>1) When running docker container we specified port 80 so you host should have this port available for docker to bind to on you host. If it’s not then change it to something else.</p>

<p>2) If your host runs multiple containers they should listen on different ports and some kind if proxy should be running on host OS to direct requests to the proper container.</p>

<p>3) To get inside the container issue <code class="highlighter-rouge">docker exec -it flask_container /bin/bash</code>. To get the exact container name issue <code class="highlighter-rouge">docker ps</code></p>

<p>4) To follow error and access logs issue <code class="highlighter-rouge">docker logs -f flask_container</code></p>

  </div><a class="u-url" href="/2018/08/09/flask-docker.html" hidden></a>
</article>

      </div>
    </main></body>

</html>
