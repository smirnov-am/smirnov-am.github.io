<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[smirnov-am.github.io]]></title><description><![CDATA[smirnov-am.github.io]]></description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>smirnov-am.github.io</title><link>http://localhost:2368/</link></image><generator>Ghost 2.21</generator><lastBuildDate>Thu, 27 Jun 2019 20:16:23 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Calculating enterprise value with Python and Pandas (part 1). FCF]]></title><description><![CDATA[<h1 id="enterprise-value">Enterprise Value</h1><p>Value of the enterprise may be used to find out whether the price of company equity - a share - is worth what market offers. It's also used in acquisitions to get the price of the company as a whole.</p><p>In this post I'll cover 3 methods of</p>]]></description><link>http://localhost:2368/calculating-enterprise-value-with-python-and-pandas-part-1-fcf/</link><guid isPermaLink="false">5cc4b3cc79d5490c32257609</guid><category><![CDATA[Financial Modelling]]></category><dc:creator><![CDATA[Alexey Smirnov]]></dc:creator><pubDate>Tue, 19 Feb 2019 19:55:00 GMT</pubDate><media:content url="http://localhost:2368/content/images/2019/04/pyfinmod2--1-.png" medium="image"/><content:encoded><![CDATA[<h1 id="enterprise-value">Enterprise Value</h1><img src="http://localhost:2368/content/images/2019/04/pyfinmod2--1-.png" alt="Calculating enterprise value with Python and Pandas (part 1). FCF"><p>Value of the enterprise may be used to find out whether the price of company equity - a share - is worth what market offers. It's also used in acquisitions to get the price of the company as a whole.</p><p>In this post I'll cover 3 methods of Enterprise Value calculations:</p><ul><li>using accounting book</li><li>efficient market approach</li><li>discounted cash flows (DCF)</li></ul><p>The latter one - DCF - is a complex topic. So here I'll cover the first part - getting future the cash flows from cash flow statement. WACC, resulting calculations as well as market engineering and sensitivity analysis will be covered in later posts.</p><h2 id="methods-of-corporate-valuation">Methods of corporate valuation</h2><h3 id="1-using-an-accounting-book">1. Using an accounting book</h3><p>The idea behind this method is to rewrite the balance sheet in a way that all productive items are on the left side and financial items are on the right. Productive items include net working capital, property, <a href="https://www.investopedia.com/terms/i/intangibleasset.asp">intangible assets</a> (copyright, goodwill) and other fixed assets.<br>Net working capital is defined as <strong>accounts receivable</strong> + <strong>inventories</strong> - <strong>accounts payable</strong> - <strong>taxes payable</strong>. Liquid assets such as cash will go on the right side to net financial debt.</p><p>So on the right-hand - financial side - we will have net financial debt (all short and long term debt minus liquid cash), other liabilities such as pensions, equity.</p><p>After moving all the items both columns should be in balance - column sums are equal and represent company value.</p><p>I failed to find a reliable API to get the company's balance sheet so I made a Yahoo Finance parser.</p><!--kg-card-begin: code--><pre><code>from pyfinmod.yahoo_finance import YahooFinanceParser

parser = YahooFinanceParser('AAPL', 'balance-sheet')
parser.get_dataframe()
</code></pre><!--kg-card-end: code--><p>The resulting dataframe with AAPL balance sheet is:</p><!--kg-card-begin: markdown--><table>
<thead>
<tr>
<th style="text-align:left">row name</th>
<th style="text-align:right">2018-09-29</th>
<th style="text-align:right">2017-09-30</th>
<th style="text-align:right">2016-09-24</th>
<th style="text-align:right">2015-09-26</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Cash And Cash Equivalents</td>
<td style="text-align:right">2.5913e+10</td>
<td style="text-align:right">2.0289e+10</td>
<td style="text-align:right">2.0484e+10</td>
<td style="text-align:right">2.112e+10</td>
</tr>
<tr>
<td style="text-align:left">Short Term Investments</td>
<td style="text-align:right">4.0388e+10</td>
<td style="text-align:right">5.3892e+10</td>
<td style="text-align:right">4.6671e+10</td>
<td style="text-align:right">2.0481e+10</td>
</tr>
<tr>
<td style="text-align:left">Net Receivables</td>
<td style="text-align:right">4.8995e+10</td>
<td style="text-align:right">3.5673e+10</td>
<td style="text-align:right">2.9299e+10</td>
<td style="text-align:right">3.0343e+10</td>
</tr>
<tr>
<td style="text-align:left">Inventory</td>
<td style="text-align:right">3.956e+09</td>
<td style="text-align:right">4.855e+09</td>
<td style="text-align:right">2.132e+09</td>
<td style="text-align:right">2.349e+09</td>
</tr>
<tr>
<td style="text-align:left">Other Current Assets</td>
<td style="text-align:right">1.2087e+10</td>
<td style="text-align:right">1.3936e+10</td>
<td style="text-align:right">8.283e+09</td>
<td style="text-align:right">1.4691e+10</td>
</tr>
<tr>
<td style="text-align:left">Total Current Assets</td>
<td style="text-align:right">1.31339e+11</td>
<td style="text-align:right">1.28645e+11</td>
<td style="text-align:right">1.06869e+11</td>
<td style="text-align:right">8.9378e+10</td>
</tr>
<tr>
<td style="text-align:left">Long Term Investments</td>
<td style="text-align:right">1.70799e+11</td>
<td style="text-align:right">1.94714e+11</td>
<td style="text-align:right">1.7043e+11</td>
<td style="text-align:right">1.64065e+11</td>
</tr>
<tr>
<td style="text-align:left">...</td>
<td style="text-align:right">...</td>
<td style="text-align:right">...</td>
<td style="text-align:right">...</td>
<td style="text-align:right">...</td>
</tr>
</tbody>
</table>
<!--kg-card-end: markdown--><p>To calculate enterprise value <code>get_enterprise_value</code> function can be used. And I found an interesting thing about Yahoo Finance page that there are no <code>Taxes Payable</code> row and <code>Total Current Liabilities</code> do not sum up to <code>Accounts Payable</code> + <code>Short/Current Long Term Debt</code> + <code>Other Current Liabilities</code>. So my calculations might be not very precise.</p><!--kg-card-begin: code--><pre><code>from pyfinmod.yahoo_finance import YahooFinanceParser
from pyfinmod.ev import get_enterprise_value

parser = YahooFinanceParser('AAPL', 'balance-sheet')
df = parser.get_dataframe()
get_enterprise_value(df)
</code></pre><!--kg-card-end: code--><p>The result is:</p><!--kg-card-begin: code--><pre><code>2018-09-29    271960000000
2017-09-30    298811000000
2016-09-24    233939000000
2015-09-26    202067000000
</code></pre><!--kg-card-end: code--><p>Also, there is a function to calculate net working capital:</p><!--kg-card-begin: code--><pre><code>from pyfinmod.yahoo_finance import YahooFinanceParser
from pyfinmod.ev import get_net_working_capital

parser = YahooFinanceParser('AAPL', 'balance-sheet')
df = parser.get_dataframe()
get_net_working_capital(df)
</code></pre><!--kg-card-end: code--><!--kg-card-begin: code--><pre><code>2018-09-29   -43167000000
2017-09-30   -41813000000
2016-09-24   -14106000000
2015-09-26   -13737000000
</code></pre><!--kg-card-end: code--><h3 id="2-efficient-market-approach">2. Efficient market approach</h3><p>If the company is publicly traded we can calculate market cap: number of shares multiplied by the share price. This is equity. It's different from the equity in the liabilities column from the balance sheet which represents the initial amount of money invested in a business (maybe not initial if the profits were reinvested).</p><p>The efficient market approach says that we need to substitute equity from the rewritten balance sheet as in the previous approach with the one defined by the market. Here lies the explanation of the name of the approach - a market with many participants trading company's shares who have the same information gives the most accurate evaluation of the company.</p><p>After doing the substitution new balance sheet is not in balance. In that case, net working capital is recalculated to re-balance it. The new column sum is the company's value.</p><p>As we can see in September 2018 AAPL value was 271.960B according to the balance sheet. But market cap it as 1.086T.</p><!--kg-card-begin: code--><pre><code>from pyfinmod.yahoo_finance import YahooFinanceParser
from pyfinmod.ev import get_enterprise_value_efficient_market

parser = YahooFinanceParser('AAPL', 'balance-sheet')
df = parse.get_dataframe()
get_enterprise_value_efficient_market(df, 1086*10**9)
</code></pre><!--kg-card-end: code--><!--kg-card-begin: code--><pre><code>2017-09-30    1250764000000
2016-09-24    1191690000000
2015-09-26    1168712000000
</code></pre><!--kg-card-end: code--><p>This is a resulting enterprise value given market cap.</p><h3 id="3-discounted-cash-flows">3. Discounted cash flows</h3><p>This approach aims to evaluate a company by its ability to generate money in future.<br>It uses two terms: Future Cash Flows (<a href="https://www.investopedia.com/terms/f/freecashflow.asp">FCF</a>) and Weighted Average Cost of Capital (<a href="https://www.investopedia.com/terms/w/wacc.asp">WACC</a>)</p><p>FCFs are defined as the cash created by the company’s operating activities. WACC is the risk-adjusted discount rate appropriate to the risk of the FCFs. And the value of the company is calculated as net present value of FCFs discounted at WACC.</p><p>There is one assumption to this approach is that cash flows occur approximately mid-year. In that case, the formula for the enterprise value (EV) is:</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/04/2019-04-29-19.27.38.jpg" class="kg-image" alt="Calculating enterprise value with Python and Pandas (part 1). FCF"></figure><!--kg-card-end: image--><p>There are two steps in getting FCFs:</p><ul><li>get historical FCFs either from pro forma or cash flow statements</li><li>project FCFs to the future assuming growth percentages</li></ul><p>I'll skip pro forma method for now</p><h4 id="fcf-from-cash-flow-statement">FCF from cash flow statement</h4><p>We need to add up these rows from the cash flow statement:</p><ul><li>Total Cash Flow From Operating Activities</li><li>Total Cash Flows From Investing Activities</li><li>Add back after-tax net interest</li></ul><p>The latter is calculated as (1 - <strong>Income tax rate</strong>) * <strong>Cash paid for Interest</strong>.<br><strong>Cash paid for interest</strong> is absolute the value of <code>Interest Expense</code>. <strong>Income tax rate</strong> equals <code>Income Tax Expense</code> / (<code>Net Income</code> + <code>Income Tax Expense</code>).</p><p><code>Income Tax Expense</code> and <code>Interest Expense</code> are taken from the  income statement. <code>Net Income</code> is taken from cash flow statement.</p><p>Example:</p><!--kg-card-begin: code--><pre><code>from pyfinmod.ev import get_fcf_from_cscf
balance_sheet_parser = YahooFinanceParser('AAPL', 'balance-sheet')
balance_sheet = balance_sheet_parser.get_dataframe()

income_statement_parser = YahooFinanceParser('AAPL', 'income-statement')
income_statement = income_statement_parser.get_dataframe()

get_fcf_from_cscf(income_statement, cash_flow)
</code></pre><!--kg-card-end: code--><!--kg-card-begin: code--><pre><code>2018-09-29    9.614571e+10
2017-09-30    1.953155e+10
2016-09-24    2.133789e+10
2015-09-26    2.553172e+10
</code></pre><!--kg-card-end: code--><p>In the next posts, I'll cover WACC calculation and DCF method usage.<br>Code is in the repo <a href="https://github.com/smirnov-am/pyfinmod">here</a>.<br>Feel free to reach out to me over <a href="https://www.linkedin.com/in/smirnovam/">LinkedIn</a> for any questions or corrections.</p>]]></content:encoded></item><item><title><![CDATA[Basic Financial Calculations with Python and Pandas]]></title><description><![CDATA[<p>In this post I'll cover:</p><ul><li>Net present value (NPV)</li><li>Internal rate of return (IRR)</li><li>Payment schedules and loan tables</li><li>Future value</li><li>Pension and accumulation problems</li><li>Continuously compounded interest</li></ul><h2 id="net-present-value">Net present value</h2><p>Present value allows to answer a simple question "should I put my money in a bank or invest". Let's</p>]]></description><link>http://localhost:2368/basic-financial-calculations-with-python-and-pandas/</link><guid isPermaLink="false">5cc4b22679d5490c322575ef</guid><category><![CDATA[Financial Modelling]]></category><dc:creator><![CDATA[Alexey Smirnov]]></dc:creator><pubDate>Mon, 24 Dec 2018 19:48:00 GMT</pubDate><media:content url="http://localhost:2368/content/images/2019/04/pyfinmod1.png" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2019/04/pyfinmod1.png" alt="Basic Financial Calculations with Python and Pandas"><p>In this post I'll cover:</p><ul><li>Net present value (NPV)</li><li>Internal rate of return (IRR)</li><li>Payment schedules and loan tables</li><li>Future value</li><li>Pension and accumulation problems</li><li>Continuously compounded interest</li></ul><h2 id="net-present-value">Net present value</h2><p>Present value allows to answer a simple question "should I put my money in a bank or invest". Let's say I have $100 and the bank gives a 12% annual interest rate. Alternatively, I can lend this money to a friend and he promises to pay $10 for 12 months. The moral aspect aside NPV gives an answer which alternative is more profitable.</p><p>The second alternative can be described as a series of cash flows:</p><ul><li>-$100 at month=0</li><li>+$10 at month=1</li><li>...</li><li>+$10 at month=12</li></ul><p>At each period value should be adjusted by the interest rate (also called the discount rate) using formula</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/04/2019-04-29-19.27.19.jpg" class="kg-image" alt="Basic Financial Calculations with Python and Pandas"></figure><!--kg-card-end: image--><p>This basic concept shows that $100 now is not the same as $100 promised in a year. $100 now is $110 in a year.</p><p>To calculate the discounted value I'll convert annual discount (interest) rate to daily and use the number of days elapsed as <em>t</em>. The function accepts a dataframe with a date column and a cash flow column.</p><!--kg-card-begin: code--><pre><code>def npv(dataframe, 
        annual_discount_rate, 
        cash_flow_column_name='cash flow', 
        date_column_name='date'):
    date_start = dataframe[date_column_name].min()
    mapper = lambda x: _calculate_discounted(x[cash_flow_column_name], 
                                             annual_discount_rate, 
                                             (x[date_column_name] - date_start).days)
    return dataframe[[cash_flow_column_name, date_column_name]].apply(mapper, axis=1).sum()

def _calculate_discounted(cf, annual_interest_rate, days_passed):
    daily_interest_rate = convert_ir(annual_interest_rate, from_period='year', to_period='day')
    return cf / (1 + daily_interest_rate)**days_passed
</code></pre><!--kg-card-end: code--><p>Let's calculate NPV of lending to a friend:</p><!--kg-card-begin: code--><pre><code>&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from datetime import date, timedelta
&gt;&gt;&gt; from dateutil.relativedelta import relativedelta
&gt;&gt;&gt; dates = [date.today() + relativedelta(months=i) for i in range(13)]
&gt;&gt;&gt; df = pd.DataFrame(data={'cash flow': [-100] + [10]*12, 
                            'date': dates})
&gt;&gt;&gt; npv(df, 0.1)
14.011086147172053
</code></pre><!--kg-card-end: code--><p>The calculated NPV of lending alternative is ~$14 which means that it is profitable. This value represents your wealth increment.  Companies use NPV<br>to calculate if it's, for example, viable to invest in a factory that will generate cash flows in the future or it's better to put the money elsewhere.</p><p><code>npv</code> function can also operate with time-dated cash flows - that is when the cash flows are not evenly placed.</p><h2 id="internal-rate-of-returns">Internal rate of returns</h2><p>So I decided to lend to a friend. What is the effective interest rate for this alternative? Internal rate of returns (IRR) answers that. The solution of the following equation for <em>r</em> gives IRR:</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/04/2019-04-29-19.27.27.jpg" class="kg-image" alt="Basic Financial Calculations with Python and Pandas"></figure><!--kg-card-end: image--><p>Effectively we are finding interest rate when NPV is 0.</p><p>The function will accept the same dataframe as an input. I'm using scipy numerical <a href="https://docs.scipy.org/doc/scipy-0.13.0/reference/generated/scipy.optimize.fsolve.html">solver</a> to find <em>r</em>. The solver accepts the initial <em>guess</em> argument which helps to find the solution.</p><!--kg-card-begin: code--><pre><code>def irr(dataframe, guess=0, cash_flow_column_name='cash flow', date_column_name='date'):
    f = partial(npv, dataframe, cash_flow_column_name=cash_flow_column_name)
    result = fsolve(f, guess)
    return list(result)
</code></pre><!--kg-card-end: code--><!--kg-card-begin: code--><pre><code>&gt;&gt;&gt; irr(df, 0.0)
[0.41354120272404077]
</code></pre><!--kg-card-end: code--><p>Lending to a friend has an effective interest rate of 41%</p><p>Sometimes a series of cash flows can have more than one IRR. We can play with <em>guess</em> to find both solutions.</p><!--kg-card-begin: code--><pre><code>&gt;&gt;&gt; dates = [date.today() + relativedelta(years=i) for i in range(6)]
&gt;&gt;&gt; df3 = pd.DataFrame(data={'cash flow': [-145, 100, 100, 100, 100, -275],                              'date': dates})
&gt;&gt;&gt; irr(df3, 0.1), irr(df3, 0.4)
([0.08793680470699422], [0.26585705483081506])
</code></pre><!--kg-card-end: code--><h2 id="flat-payment-schedules">Flat payment schedules</h2><p>Let's look at the lending problems from the friend's point of view. He knows that with the cash flow he proposed he will be paying 41% annual interest rate. He wants to lower the interest rate to say 30% and calculates a new flat payment scheme. Flat here means that he will pay a constant amount each month for a <em>term</em> amount of months.</p><p>First, let's calculate the monthly payment. Function argument will be</p><ul><li><em>principal</em> - the lending amount</li><li><em>annual_interest_rate</em> - agreed interest rate in a term of a year</li><li><em>term</em> - how many terms to pay</li><li><em>period</em> - unit of a <em>term</em></li></ul><!--kg-card-begin: code--><pre><code>def pmt(principal, annual_interest_rate, term, period='year'):
    periodic_interest = convert_ir(annual_interest_rate, from_period='year', to_period=period)
    payment = (principal*periodic_interest)/(1 - (1 + periodic_interest)**(-term))
    return payment
</code></pre><!--kg-card-end: code--><!--kg-card-begin: code--><pre><code>&gt;&gt;&gt; pmt(100, 0.3, 12, period='month')
9.57859525723352
</code></pre><!--kg-card-end: code--><p>So he will be paying ~$9.6 each month. Now he wants to know how fast he's re-paying the interest and the principal. For that, a loan table is used.</p><!--kg-card-begin: code--><pre><code>def flat_payments(principal, annual_interest_rate, term, period='year'):
    _pmt = pmt(principal, annual_interest_rate, term, period=period)
    data = defaultdict(list)
    current_principal = principal
    principal_col_name = 'principal at the beginning of {}'.format(period)
    payment_col_name = 'payment at the end of {}'.format(period)
    interest_col_name = 'interest'
    return_principal_col_name = 'return of principal'
    periodic_interest = convert_ir(annual_interest_rate, from_period='year', to_period=period)
    for _t in range(1, term + 1):
        data[period].append(_t)
        data[principal_col_name].append(current_principal)
        data[payment_col_name] = _pmt
        current_interest = current_principal * periodic_interest
        data[interest_col_name].append(current_interest)
        current_return_of_principal = _pmt - current_interest
        data[return_principal_col_name].append(current_return_of_principal)
        current_principal -= current_return_of_principal  
    assert round(current_principal) == 0
    return pd.DataFrame.from_dict(data)
</code></pre><!--kg-card-end: code--><!--kg-card-begin: code--><pre><code>&gt;&gt;&gt; res_df = flat_payments(100, 0.3, 12, period='month')
&gt;&gt;&gt; print(tabulate(res_df, tablefmt="pipe", headers="keys"))
</code></pre><!--kg-card-end: code--><!--kg-card-begin: markdown--><table>
<thead>
<tr>
<th style="text-align:right"></th>
<th style="text-align:right">month</th>
<th style="text-align:right">principal at the beginning of month</th>
<th style="text-align:right">payment at the end of month</th>
<th style="text-align:right">interest</th>
<th style="text-align:right">return of principal</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">0</td>
<td style="text-align:right">1</td>
<td style="text-align:right">100</td>
<td style="text-align:right">9.5786</td>
<td style="text-align:right">2.21045</td>
<td style="text-align:right">7.36815</td>
</tr>
<tr>
<td style="text-align:right">1</td>
<td style="text-align:right">2</td>
<td style="text-align:right">92.6318</td>
<td style="text-align:right">9.5786</td>
<td style="text-align:right">2.04758</td>
<td style="text-align:right">7.53102</td>
</tr>
<tr>
<td style="text-align:right">2</td>
<td style="text-align:right">3</td>
<td style="text-align:right">85.1008</td>
<td style="text-align:right">9.5786</td>
<td style="text-align:right">1.88111</td>
<td style="text-align:right">7.69749</td>
</tr>
<tr>
<td style="text-align:right">3</td>
<td style="text-align:right">4</td>
<td style="text-align:right">77.4033</td>
<td style="text-align:right">9.5786</td>
<td style="text-align:right">1.71096</td>
<td style="text-align:right">7.86764</td>
</tr>
<tr>
<td style="text-align:right">4</td>
<td style="text-align:right">5</td>
<td style="text-align:right">69.5357</td>
<td style="text-align:right">9.5786</td>
<td style="text-align:right">1.53705</td>
<td style="text-align:right">8.04155</td>
</tr>
<tr>
<td style="text-align:right">5</td>
<td style="text-align:right">6</td>
<td style="text-align:right">61.4942</td>
<td style="text-align:right">9.5786</td>
<td style="text-align:right">1.35929</td>
<td style="text-align:right">8.2193</td>
</tr>
<tr>
<td style="text-align:right">6</td>
<td style="text-align:right">7</td>
<td style="text-align:right">53.2749</td>
<td style="text-align:right">9.5786</td>
<td style="text-align:right">1.17761</td>
<td style="text-align:right">8.40098</td>
</tr>
<tr>
<td style="text-align:right">7</td>
<td style="text-align:right">8</td>
<td style="text-align:right">44.8739</td>
<td style="text-align:right">9.5786</td>
<td style="text-align:right">0.991912</td>
<td style="text-align:right">8.58668</td>
</tr>
<tr>
<td style="text-align:right">8</td>
<td style="text-align:right">9</td>
<td style="text-align:right">36.2872</td>
<td style="text-align:right">9.5786</td>
<td style="text-align:right">0.802108</td>
<td style="text-align:right">8.77649</td>
</tr>
<tr>
<td style="text-align:right">9</td>
<td style="text-align:right">10</td>
<td style="text-align:right">27.5107</td>
<td style="text-align:right">9.5786</td>
<td style="text-align:right">0.608109</td>
<td style="text-align:right">8.97049</td>
</tr>
<tr>
<td style="text-align:right">10</td>
<td style="text-align:right">11</td>
<td style="text-align:right">18.5402</td>
<td style="text-align:right">9.5786</td>
<td style="text-align:right">0.409821</td>
<td style="text-align:right">9.16877</td>
</tr>
<tr>
<td style="text-align:right">11</td>
<td style="text-align:right">12</td>
<td style="text-align:right">9.37144</td>
<td style="text-align:right">9.5786</td>
<td style="text-align:right">0.207151</td>
<td style="text-align:right">9.37144</td>
</tr>
</tbody>
</table>
<!--kg-card-end: markdown--><p>I'm using <a href="https://pypi.org/project/tabulate/">tabulate</a> to print dataframes in the terminal.</p><p>The last two columns - <em>interest</em> and <em>return of principal</em> - show how the payment is split between repaying interest and principal. At the end, principal value should be 0 (see assert in function code). It's interesting to know how much interest is re-payed because that amount sometimes is tax deductible.</p><h2 id="future-value">Future value</h2><p>Let’s imagine we put $10000 today for 10 years with an annual interest rate 10%. How much money we will have in 10 years? Using this formula with r=0.1 ant t=10 will give us $2593.74:</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/04/2019-04-29-19.27.34.jpg" class="kg-image" alt="Basic Financial Calculations with Python and Pandas"></figure><!--kg-card-end: image--><p>A slightly more complex problem is if we want to deposit some money during these 10 years. The f<em>uture value</em> will tell how much money we'll have in the end of the period.</p><p>The function accepts a list of deposit amounts and, annual interest rate and a period at which deposits are made</p><!--kg-card-begin: code--><pre><code>def fv(deposits, annual_interest_rate, period='year'):
    periodic_interest = convert_ir(annual_interest_rate, from_period='year', to_period=period)
    future_value = 0
    number_of_deposits = len(deposits)
    for n, deposit in enumerate(deposits):
        future_value += deposit * (1 + periodic_interest)**(number_of_deposits - n)
    return future_value
</code></pre><!--kg-card-end: code--><!--kg-card-begin: code--><pre><code>&gt;&gt;&gt; fv([1000 for _ in range(10)], 0.1, period='year')
17531.16706110001
</code></pre><!--kg-card-end: code--><p>So depositing $1000 for 10 years will yield $17.5k given the interest rate is 10%.</p><h2 id="retirement-problem">Retirement problem</h2><p>Consider the following exercise. Now I'm 31 and planning to retire at 55 (24 more years working). After retiring I'm planning to live at least 25 more years and will need, say, $50000 a year. To support my retirement I need to deposit money into a bank account with known interest rate (say 5%). What's the minimum amount do I need to deposit each year?</p><p>This problem implies a number of cash flows: 24 terms with CF=<em>x</em> at each time, and 25 terms with CF=-50000. The present value of this cash flows should be 0. Solving this equation for <em>x</em> will give the minimum annual deposit. The minimum deposit is used here not in a mathematical sense, but more in common sense - I'll live more that 25 years after retirement, prices are also going up so I'll need more than 50k yearly.</p><!--kg-card-begin: code--><pre><code>def get_retirement_cf_dataframe(deposit, terms_of_deposit, withdrawal, terms_of_withdrawal, period='year'):
    cash_flows = [deposit]*terms_of_deposit + [-withdrawal]*terms_of_withdrawal
    terms = terms_of_deposit + terms_of_withdrawal
    dates = [date.today() + relativedelta(**{period + 's':i}) for i in range(terms)]
    df = pd.DataFrame(data={'cash flow': cash_flows, 'date': dates})
    return df


def retirement_problem(terms_of_deposit, 
                       withdrawal, 
                       terms_of_withdrawal, 
                       annual_discount_rate, 
                       period='year'):
    df_by_deposit = partial(get_retirement_cf_dataframe, 
                            terms_of_deposit=terms_of_deposit, 
                            withdrawal=withdrawal, 
                            terms_of_withdrawal=terms_of_withdrawal, 
                            period=period)
    f = lambda deposit: npv(retirement_dataframe_by_deposit(deposit), annual_discount_rate)
    result = fsolve(f, withdrawal)
    return list(result)
</code></pre><!--kg-card-end: code--><!--kg-card-begin: code--><pre><code>&gt;&gt;&gt; retirement_problem(24, 50000, 25, 0.05)
[15822.327630785972]
</code></pre><!--kg-card-end: code--><p>That's a pretty cool result - I need to deposit only ~$16k yearly for 24 years to be able to withdraw $50k for 25 years later. That's compound interest working.</p><h2 id="continuous-compounding">Continuous compounding</h2><p>I'm using <code>convert_ir(r, from_period='year', to_period='day')</code> function to convert from annual interest rate to daily interest rate in some examples above.<br>So if I have an annual rate of 20%, a quarterly rate is:</p><!--kg-card-begin: code--><pre><code>&gt;&gt;&gt; convert_ir(0.2, from_period='year', to_period='quater')
0.04663513939210562
</code></pre><!--kg-card-end: code--><p>And respective annual is:</p><!--kg-card-begin: code--><pre><code>&gt;&gt;&gt; 4 * convert_ir(0.2, from_period='year', to_period='quater')
</code></pre><!--kg-card-end: code--><p>So if a bank offers a 20% annual interest rate paid quarterly the effective annual interest rate is 18.6%. So if the number of interest payments increases - for example to every millisecond -  this is called continuous compounding. Let's calculate the annual interest rate continuously compounded given initial and end amounts.</p><!--kg-card-begin: code--><pre><code>def get_annual_rate_cc(dataframe, amount_column_name='amount', date_column_name='date'):
    amount_first = dataframe[amount_column_name].iloc[0]
    amount_last = dataframe[amount_column_name].iloc[-1]
    date_first = dataframe[date_column_name].iloc[0]
    date_last = dataframe[date_column_name].iloc[-1]
    delta = relativedelta(date_last, date_first)
    t = delta.years + delta.months/12 + delta.days/365
    r = log(amount_last/amount_first)/t
    return r
</code></pre><!--kg-card-end: code--><!--kg-card-begin: code--><pre><code>&gt;&gt;&gt; df = pd.DataFrame(data={'amount': [1000, 1500], 'date': [date.today(), date.today() + relativedelta(years=1, months=9)]})
&gt;&gt;&gt; print(tabulate(df, tablefmt="pipe", headers="keys"))
</code></pre><!--kg-card-end: code--><!--kg-card-begin: markdown--><table>
<thead>
<tr>
<th style="text-align:right"></th>
<th style="text-align:right">amount</th>
<th style="text-align:left">date</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">0</td>
<td style="text-align:right">1000</td>
<td style="text-align:left">2018-12-24</td>
</tr>
<tr>
<td style="text-align:right">1</td>
<td style="text-align:right">1500</td>
<td style="text-align:left">2020-09-24</td>
</tr>
</tbody>
</table>
<!--kg-card-end: markdown--><!--kg-card-begin: code--><pre><code>&gt;&gt;&gt; get_annual_rate_cc(df)
0.23169434749037965
</code></pre><!--kg-card-end: code--><p>Continuous compounding is used in many financial calculations.</p><h2 id="code">Code</h2><p>I'm planning to gather all the financial modeling methods including the ones form this post in a repo <a href="https://github.com/smirnov-am/pyfinmod">here</a>. Feel free to reach out to me over <a href="https://www.linkedin.com/in/smirnovam/">LinkedIn</a> for any questions.</p>]]></content:encoded></item><item><title><![CDATA[Streaming timeseries with Flask and Plotly]]></title><description><![CDATA[<p>This simple app for streaming cpu utilization to a web page. I'm using Flask as websockets server (flask-socketio plugin), socket.io as client library and plotly.js<br>for visualization.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/04/demo--2-.gif" class="kg-image"></figure><!--kg-card-end: image--><h2 id="flask-app">Flask app</h2><p>I'm following a flask-socketio <a href="https://flask-socketio.readthedocs.io/en/latest/">doc</a> to create a flask app. SocketIO is going to use Redis as message broker</p>]]></description><link>http://localhost:2368/streaming-timeseries-with-flask-and-plotly/</link><guid isPermaLink="false">5cc4b0c979d5490c322575c6</guid><category><![CDATA[Flask]]></category><dc:creator><![CDATA[Alexey Smirnov]]></dc:creator><pubDate>Wed, 12 Dec 2018 19:43:00 GMT</pubDate><media:content url="http://localhost:2368/content/images/2019/04/task-manager-3-.png" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2019/04/task-manager-3-.png" alt="Streaming timeseries with Flask and Plotly"><p>This simple app for streaming cpu utilization to a web page. I'm using Flask as websockets server (flask-socketio plugin), socket.io as client library and plotly.js<br>for visualization.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/04/demo--2-.gif" class="kg-image" alt="Streaming timeseries with Flask and Plotly"></figure><!--kg-card-end: image--><h2 id="flask-app">Flask app</h2><p>I'm following a flask-socketio <a href="https://flask-socketio.readthedocs.io/en/latest/">doc</a> to create a flask app. SocketIO is going to use Redis as message broker as there will be a separate process that pushes messages to clients. Flask websocket server and this process will communicate through Redis.</p><!--kg-card-begin: code--><pre><code>def create_app(register_blueprint=True):
    app = Flask(__name__)
    app.secret_key = os.urandom(42)
    if register_blueprint:
        app.register_blueprint(plotting_blueprint)

    socketio = SocketIO(app, message_queue='redis://localhost:6379/')
    socketio.on_event('connect', bootstrap_on_connect)
    return socketio, app


socketio, application = create_app()


if __name__ == '__main__':
    socketio.run(application)
</code></pre><!--kg-card-end: code--><p>Here I'm defining first hook - when client connects we are going to send him some history data - the task for <code>bootstrap_on_connect</code> functions.</p><p>The blueprint I'm defining is simple one that has only one route that serves a static page. This page will load client's javascript. The only parameter is window size - I'd like to see only last 100 seconds of data.</p><!--kg-card-begin: code--><pre><code>from flask import Blueprint, render_template

plotting_blueprint = Blueprint('plotting', __name__)


@plotting_blueprint.route('/')
def index():
    return render_template('index.html', x_window=100)

</code></pre><!--kg-card-end: code--><h2 id="template-and-client-code">Template and client code</h2><p>In the template I'm putting window size inside meta tag so JS will be able to read that.<br>Also I'm loading all libraries in the end of body</p><!--kg-card-begin: code--><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="x_window" content={{x_window}}&gt;
    &lt;title&gt;Flask data viz&lt;/title&gt;
    &lt;link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='styles.css') }}"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="plot"&gt;&lt;/div&gt;
&lt;script src="https://cdn.plot.ly/plotly-latest.min.js"&gt;&lt;/script&gt;
&lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.6/socket.io.min.js"&gt;&lt;/script&gt;
&lt;script src="{{ url_for('static', filename='plot.js') }}"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><!--kg-card-end: code--><p><code>plot.js</code> will contain all client-side logic.</p><!--kg-card-begin: code--><pre><code>var url = 'http://' + document.domain + ':' + location.port
var socket = io.connect(url);

socket.on('connect', function(msg) {
    console.log('connected to websocket on ' + url);
});

socket.on('bootstrap', function (msg) {
    plot_start = msg.x[0];
    makePlotly( msg.x, msg.y )
});

socket.on('update', function (msg) {
    streamPlotly( msg.x, msg.y )
});
</code></pre><!--kg-card-end: code--><p>First we connect to websocket (using HTTP, not WS protocol). When connected Flask will send us <code>bootstrap</code> message with initial data. Here <code>makePlotly</code> function is invoked. It will initialize plotly stuff. When <code>update</code> message is received <code>streamPlotly</code> will use <code>Plotly.extendTraces</code> to add data to plotly traces. It also updates the layout so we'll have nice sliding window.</p><h2 id="running-the-app">Running the app</h2><p>To run the app I'm using uwsgi with gevent. uwsgi config:</p><!--kg-card-begin: code--><pre><code>[uwsgi]
module = app:application
uid = www-data

http = 127.0.0.1:5000

gevent-monkey-patch = true
http-websockets = true
gevent = 1000

</code></pre><!--kg-card-end: code--><p>Protocol for websockets is going to be HTTP so uwsgi will listen on port 5000 instead of communication through UNIX socket with nginx.</p><p>Nginx config should create a separate location for websocket url</p><!--kg-card-begin: code--><pre><code>server {
    listen       80 default_server;
    listen       [::]:80 default_server;
    server_name  localhost;
    root         /var/www/html;
    client_max_body_size 16M;

    location / {
        include proxy_params;
        proxy_pass http://127.0.0.1:5000;
    }

    location /socket.io {
        include proxy_params;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "Upgrade";
        proxy_set_header Host $host;
        proxy_pass http://127.0.0.1:5000/socket.io;
    }
}
</code></pre><!--kg-card-end: code--><h3 id="background-job">Background job</h3><p>A separate process gets CPU utilization with <code>psutil</code> and pushes message to clients.<br>Also it defines bootstrap function - but I'm just starting with empty lists for now.</p><p><code>streaming.py</code>:</p><!--kg-card-begin: code--><pre><code>#!/usr/bin/env python
import time
from datetime import datetime
from psutil import cpu_percent
from flask_socketio import emit, SocketIO

DATE_FMT = "%Y-%m-%d %H:%M:%S"


def bootstrap_on_connect():
    emit('bootstrap', {'x': [datetime.now().strftime(DATE_FMT)], 'y': [0]})


def update_plot():
    socketio = SocketIO(message_queue='redis://localhost:6379/')
    while True:
        datetime_now = datetime.now().strftime(DATE_FMT)
        cpu_percent_second = cpu_percent(interval=1)
        socketio.emit('update', {'x': [datetime_now], 'y': [cpu_percent_second]})
        time.sleep(1)


if __name__ == '__main__':
    update_plot()
</code></pre><!--kg-card-end: code--><h2 id="running-it-all">Running it all</h2><ol><li>Install redis server and nginx</li><li>Run uwsgi with <code>uwsgi --ini uwsgi.ini</code></li><li>Install all dependencies from requirements.txt into virtual environment</li><li>Run streaming.py (<code>chmod +x streaming.py &amp;&amp; ./streaming.py</code>)</li></ol><h2 id="further-thoughts">Further thoughts</h2><p>There is no persistence to the data and newly connected client won't be able to see the history. For this some kind of storage is needed. Another approach is to periodically call Flask from javascript to get the data though AJAX call.<br>I find a websocket solution more interesting - but more complex - because it allows<br>to have a separate process to update clients, that offloads some work from web server.</p><p>Full code is available from this <a href="https://github.com/smirnov-am/flask-streaming">repo</a></p><p>Do you use websockets for streaming live data? Connect with me on <a href="https://www.linkedin.com/in/smirnovam/">linkedin</a> to discuss it.</p>]]></content:encoded></item><item><title><![CDATA[Background jobs with Flask]]></title><description><![CDATA[<p>Basic request lifecycle with Flask goes like this:</p><ul><li>Flask get request</li><li>parse parameters</li><li>does calculations</li><li>returns result</li></ul><p>This synchronous task is fine when user needs the result of calculation immediately.<br>Another use case is when the result is not relevant right now and user just wants to schedule an execution</p>]]></description><link>http://localhost:2368/background-jobs-with-flask/</link><guid isPermaLink="false">5cc4af2c79d5490c3225758f</guid><category><![CDATA[Flask]]></category><dc:creator><![CDATA[Alexey Smirnov]]></dc:creator><pubDate>Tue, 27 Nov 2018 19:41:00 GMT</pubDate><media:content url="http://localhost:2368/content/images/2019/04/800px_COLOURBOX2362664.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2019/04/800px_COLOURBOX2362664.jpg" alt="Background jobs with Flask"><p>Basic request lifecycle with Flask goes like this:</p><ul><li>Flask get request</li><li>parse parameters</li><li>does calculations</li><li>returns result</li></ul><p>This synchronous task is fine when user needs the result of calculation immediately.<br>Another use case is when the result is not relevant right now and user just wants to schedule an execution of the task asynchronously.</p><p>Such scenarios include:</p><ul><li>sending email</li><li>creating thumbnails from uploaded image</li></ul><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/04/img1.png" class="kg-image" alt="Background jobs with Flask"></figure><!--kg-card-end: image--><h2 id="common-implementation">Common implementation</h2><p>Asynchronous tasks are usually implemented like this:</p><ul><li>Flask schedules a task by putting a message into message broker (Redis, AWS SQS, RabbitMQ) upon request</li><li>The broker is made available to the pool of possibly separate machines - workers</li><li>Workers get messages from broker and execute tasks</li></ul><p>This approach has a number of advantages. Firstly, it's sharing responsibility. Instances running Flask web server are doing only one job - serving requests. If the tasks are resource demanding Flask instances won't suffer from high memory/CPU usage and will still server requests. Secondly, tasks are stored in message broker.<br>If Flask instances die it won't affect workers and task execution.</p><p>Nothing comes for free. This structure has more points of failure then alternatives. Libraries serving brokers have bugs. Also it may looks like a over-engineering for simple tasks.</p><p>Here are some good examples of such implementations: <a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xxii-background-jobs">RQ</a>, <a href="https://blog.miguelgrinberg.com/post/using-celery-with-flask">Celery</a></p><h2 id="alternatives">Alternatives</h2><h3 id="threads">Threads</h3><p>Most basic approach is to run a task in a thread. For that to work this line should be added to uwsgi configuration file:</p><!--kg-card-begin: code--><pre><code>enable-threads = true
</code></pre><!--kg-card-end: code--><p>we run <a href="https://smirnov-am.github.io/2018/08/09/flask-docker.html">Flask with uwsg in production</a> of course</p><p>Code <code>app.py</code></p><!--kg-card-begin: code--><pre><code>import os
import time
from flask import Flask, jsonify
from threading import Thread
from tasks import threaded_task

app = Flask(__name__)
app.secret_key = os.urandom(42)


@app.route("/", defaults={'duration': 5})
@app.route("/&lt;int:duration&gt;")
def index(duration):
    thread = Thread(target=threaded_task, args=(duration,))
    thread.daemon = True
    thread.start()
    return jsonify({'thread_name': str(thread.name),
                    'started': True})
</code></pre><!--kg-card-end: code--><p>code <code>tasks.py</code></p><!--kg-card-begin: code--><pre><code>import time

def threaded_task(duration):
    for i in range(duration):
        print("Working... {}/{}".format(i + 1, duration))
        time.sleep(1)
</code></pre><!--kg-card-end: code--><p>Demo:</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/04/demo1.gif" class="kg-image" alt="Background jobs with Flask"></figure><!--kg-card-end: image--><h3 id="uwsgi-thread">uWSGI thread</h3><p>Creating and running thread may be delegated to uwsgi. So we don't interact with<br>threading module directly. For that there is a <code>thread</code> decorator available <code>from uwsgidecorators import thread</code> (<a href="https://uwsgi-docs.readthedocs.io/en/latest/PythonDecorators.html?highlight=thread#uwsgidecorators.thread">API docs</a>)</p><p>Code <code>app.py</code></p><!--kg-card-begin: code--><pre><code>import os
import time
from flask import Flask, jsonify
from threading import Thread
from tasks import uwsgi_task

app = Flask(__name__)
app.secret_key = os.urandom(42)


@app.route("/uwsgi_thread", defaults={'duration': 5})
@app.route("/uwsgi_thread/&lt;int:duration&gt;")
def uwsgi_thread(duration):
    uwsgi_task(duration)
    return jsonify({'started': True})
</code></pre><!--kg-card-end: code--><p>code <code>tasks.py</code></p><!--kg-card-begin: code--><pre><code>import time
from uwsgidecorators import thread


@thread
def uwsgi_task(duration):
    for i in range(duration):
        print("Working in uwsgi thread... {}/{}".format(i + 1, duration))
        time.sleep(1)
</code></pre><!--kg-card-end: code--><p>Demo:</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/04/demo2.gif" class="kg-image" alt="Background jobs with Flask"></figure><!--kg-card-end: image--><h3 id="uwsgi-spooler">uWSGI spooler</h3><p>Above examples create a thread per request and can lead to some troubles when there are many of them. To control that a task may run in a <a href="https://uwsgi-docs.readthedocs.io/en/latest/Spooler.html?highlight=spooler">spooler</a> with controlled number of executors.<br>This however requires some configuration from uwsgi side (that is <code>uwsgi.ini</code>)</p><ul><li><code>spooler = my_spools</code> - a path to a directory to store files representing tasks. Directory should be created beforehand.</li><li><code>spooler-import = tasks.py</code> - a module containing task's code spooler workers will import</li><li><code>spooler-frequency = 1</code> - how ofter workers scan spool directory for tasks</li><li><code>spooler-processes = 10</code> - how many workers to run</li></ul><p>After running <code>uwsgi --ini uwsgi.ini</code> startup log shows created processes:</p><!--kg-card-begin: code--><pre><code>spawned the uWSGI spooler on dir /home/as/Desktop/blog/my_spools with pid 10609
spawned the uWSGI spooler on dir /home/as/Desktop/blog/my_spools with pid 10610
spawned the uWSGI spooler on dir /home/as/Desktop/blog/my_spools with pid 10611
spawned the uWSGI spooler on dir /home/as/Desktop/blog/my_spools with pid 10612
spawned the uWSGI spooler on dir /home/as/Desktop/blog/my_spools with pid 10613
spawned the uWSGI spooler on dir /home/as/Desktop/blog/my_spools with pid 10614
spawned the uWSGI spooler on dir /home/as/Desktop/blog/my_spools with pid 10615
spawned the uWSGI spooler on dir /home/as/Desktop/blog/my_spools with pid 10616
spawned the uWSGI spooler on dir /home/as/Desktop/blog/my_spools with pid 10617
spawned the uWSGI spooler on dir /home/as/Desktop/blog/my_spools with pid 10618
spawned uWSGI worker 1 (pid: 10619, cores: 1)
spawned uWSGI worker 2 (pid: 10620, cores: 1)
spawned uWSGI worker 3 (pid: 10621, cores: 1)
spawned uWSGI worker 4 (pid: 10622, cores: 1)
spawned uWSGI worker 5 (pid: 10623, cores: 1)
</code></pre><!--kg-card-end: code--><p><code>tasks.py</code> code is straightforward and use <code>spool</code> decorator from uwsgi.<br>The task function itself should return a predefined codes though:</p><ul><li><code>uwsgi.SPOOL_OK</code> if all went well</li><li><code>uwsgi.SPOOL_RETRY</code> if a jobs needs to be retried (if it's idempotent of course)</li></ul><!--kg-card-begin: code--><pre><code>import time
import uwsgi
from uwsgidecorators import spool


@spool
def spool_task(args):
    try:
        duration = int(args['duration'])
        for i in range(duration):
            print("Working in uwsgi spool... {}/{}".format(i + 1, duration))
            time.sleep(1)
        return uwsgi.SPOOL_OK
    except:
        return uwsgi.SPOOL_RETRY
</code></pre><!--kg-card-end: code--><p><code>app.py</code> calls <code>spool_task</code> in the route, but I struggled a but with passing parameters.<br>I was getting such error when passing them according to the docs:</p><!--kg-card-begin: code--><pre><code>ValueError: spooler callable dictionary must contains only bytes
</code></pre><!--kg-card-end: code--><p>So I came up with simple helper that converts keyword arguments to a dictionary with keys and values that have bytes only - <code>prepare_spooler_args</code>. <code>spool</code> decorator has a <code>pass_arguments</code> parameter - it may be a possible solution as well.</p><!--kg-card-begin: code--><pre><code>import os
import time
from flask import Flask, jsonify
from tasks import threaded_task, uwsgi_task, spool_task, uwsgi_tasks_task

app = Flask(__name__)
app.secret_key = os.urandom(42)


def prepare_spooler_args(**kwargs):
    args = {}
    for name, value in kwargs.items():
        args[name.encode('utf-8')] = str(value).encode('utf-8')
    return args


@app.route("/uwsgi_spool", defaults={'duration': 5})
@app.route("/uwsgi_spool/&lt;int:duration&gt;")
def uwsgi_spool(duration):
    args = prepare_spooler_args(duration=duration)
    spool_task.spool(args)
    return jsonify({'started': True})
</code></pre><!--kg-card-end: code--><p>Also <code>spool_task.spool</code> accepts an <code>at</code> parameter that tell spooler to run a task at a specified unix timestamp. To use it <code>uwsgi_spool</code> route code:</p><!--kg-card-begin: code--><pre><code>@app.route("/uwsgi_spool", defaults={'duration': 5})
@app.route("/uwsgi_spool/&lt;int:duration&gt;")
def uwsgi_spool(duration):
    at = int(time.time()) + 3 # delay by 3s
    args = prepare_spooler_args(duration=duration, at=at)
    spool_task.spool(args)
    return jsonify({'started': True})
</code></pre><!--kg-card-end: code--><p>Demo:</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/04/demo3.gif" class="kg-image" alt="Background jobs with Flask"></figure><!--kg-card-end: image--><h3 id="wrapping-up-spooler">Wrapping up spooler</h3><p><code>uwsgi-tasks</code> library (<a href="https://pypi.org/project/uwsgi-tasks/">pypi</a>) wraps all the uwsgi spooler workings, especially argument passing. Also I found controlling retries as a useful feature.<br>Unfortunately after installing it previous example (bareback spooler) stopped working for me.</p><h2 id="further-thoughts-">Further thoughts.</h2><p>uSWGI spooler is great for simple tasks. It becomes more robust with external spooler support and networking, but at that level it starts resemble a common approach with all it's drawbacks.</p><p>The whole code is available at <a href="https://github.com/smirnov-am/flask-bg-tasks">GitHub</a></p><p>Do you use background jobs with Flask? Drop me a message on <a href="https://www.linkedin.com/in/smirnovam/">linkedin</a></p>]]></content:encoded></item><item><title><![CDATA[Multitenancy with Flask]]></title><description><![CDATA[<h3 id="what-is-multitenancy">What is multitenancy</h3><p>Consider a SaaS platform that provide access to multiple client organizations.<br>These organizations - tenants - may have each its own database for safety and data protection reasons.<br>It can be a database on a single RDBMS server or physically different servers.<br>Usually additional central database (i.</p>]]></description><link>http://localhost:2368/multitenancy-with-flask/</link><guid isPermaLink="false">5cc4988279d5490c32257576</guid><category><![CDATA[Flask]]></category><dc:creator><![CDATA[Alexey Smirnov]]></dc:creator><pubDate>Fri, 26 Oct 2018 17:59:00 GMT</pubDate><media:content url="http://localhost:2368/content/images/2019/04/social-housing-landlords-tenants-scotland-act-2014-tenancy-short-secure-law-lawyer-eviction.jpg" medium="image"/><content:encoded><![CDATA[<h3 id="what-is-multitenancy">What is multitenancy</h3><img src="http://localhost:2368/content/images/2019/04/social-housing-landlords-tenants-scotland-act-2014-tenancy-short-secure-law-lawyer-eviction.jpg" alt="Multitenancy with Flask"><p>Consider a SaaS platform that provide access to multiple client organizations.<br>These organizations - tenants - may have each its own database for safety and data protection reasons.<br>It can be a database on a single RDBMS server or physically different servers.<br>Usually additional central database (i.e., General) stores metadata and list of available tenants.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/04/description.png" class="kg-image" alt="Multitenancy with Flask"></figure><!--kg-card-end: image--><h3 id="flask-sqlalchemy">Flask-SQLAlchemy</h3><p>Flask-SQLAlchemy provides interface only to one database.<br>Flask app configuration defines <code>SQLALCHEMY_DATABASE_URI</code> gives connection info and database name.<br>It possible to extend it to multiple tenant databases using <a href="http://flask-sqlalchemy.pocoo.org/2.3/binds/">binds</a></p><h3 id="tenant-dependent-endpoint">Tenant dependent endpoint</h3><p>Consider this endpoint that displays tenant users and gets tenant name<br>as its parameter</p><!--kg-card-begin: code--><pre><code>@app.route("/&lt;tenant_name&gt;/users")
def index(tenant_name):
    tenant_session = get_tenant_session(tenant_name)
    if not tenant_session:
        abort(404)
    users = tenant_session.query(User).all()
    return jsonify({tenant_name: [i.username for i in users]})
</code></pre><!--kg-card-end: code--><p>Models used are very basic:</p><!--kg-card-begin: code--><pre><code>class User(db.Model):
    __tablename__ = 'users'

    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(100), nullable=False)


class Tenant(db.Model):
    __tablename__ = 'tenants'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
</code></pre><!--kg-card-end: code--><p>For users it's just id and username. These tables are in tenant database.<br>And tenant model is in general database. I keep track of available tenants here so<br>if query refers to unknown tenant it will give 404 error.</p><h3 id="building-tenant-session">Building tenant session</h3><p>To get tenant session</p><ul><li>check if tenant name is in <code>tenants</code> table from General database</li><li>create a URI in <code>SQLALCHEMY_BINDS</code> dictionary that is in Flask app configuration - <code>current_app.config</code></li><li>get SQLAlchemy engine that reads that bind</li><li>form session from a session factory - <code>sessionmaker</code> - that uses the engine</li></ul><!--kg-card-begin: code--><pre><code>MYSQL_URI = 'mysql+pymysql://user:pwd@localhost/{}?charset=utf8'


@simple_cache
def get_known_tenants():
    tenants = Tenant.query.all()
    return [i.name for i in tenants]


def prepare_bind(tenant_name):
    if tenant_name not in current_app.config['SQLALCHEMY_BINDS']:
        current_app.config['SQLALCHEMY_BINDS'][tenant_name] = MYSQL_URI.format(tenant_name)
    return current_app.config['SQLALCHEMY_BINDS'][tenant_name]


def get_tenant_session(tenant_name):
    if tenant_name not in get_known_tenants():
        return None
    prepare_bind(tenant_name)
    engine = db.get_engine(current_app, bind=tenant_name)
    session_maker = db.sessionmaker()
    session_maker.configure(bind=engine)
    session = session_maker()
    return session
</code></pre><!--kg-card-end: code--><p>I check tenant availability at every request. This information doesn't change often so it's cached.</p><h3 id="cache-slow-changing-data">Cache slow changing data</h3><p>I'll be using simple <a href="http://werkzeug.pocoo.org/docs/0.14/contrib/cache/">werkzeug cache</a>.<br>Every process and uwsgi worker will get its own instance. To share the data between processes this cache can be easily extended to use external store like Redis/Memcached.</p><p><code>Simple_cache</code> is a decorator using function name as a key like so:</p><!--kg-card-begin: code--><pre><code>cache = SimpleCache()


def simple_cache(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        function_name = f.__name__
        if cache.has(function_name):
            result = cache.get(function_name)
        else:
            result = f(*args, **kwargs)
            cache.set(function_name, result)
        return result
    return wrapper
</code></pre><!--kg-card-end: code--><h3 id="database-initialization">Database initialization</h3><p>I've prepared a SQL dump to generate mock data <a>here</a>. It creates all databases<br>and tables with two tenants: TenantA and TenantB. Each has 2 users:</p><ul><li>userA and userB for TenantA;</li><li>userA and userC for TenantB;</li></ul><p>It can be imported with mysql client</p><p><code>mysql --host="&lt;host&gt;" --user="&lt;user&gt;" --password="&lt;password&gt;" &lt; all_databases.sql</code></p><h3 id="results">Results</h3><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/04/demo--1-.gif" class="kg-image" alt="Multitenancy with Flask"></figure><!--kg-card-end: image--><p>The whole code is available at <a href="https://github.com/smirnov-am/flask-multitenancy">GitHub</a></p><p>Do you use multitenant database? Drop me a message on <a href="https://www.linkedin.com/in/smirnovam/">LinkedIn</a></p>]]></content:encoded></item><item><title><![CDATA[Flask pagination macro]]></title><description><![CDATA[<p>In this post I will cover how to create a pagination with Jinja macro feature.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/04/demo.gif" class="kg-image"></figure><!--kg-card-end: image--><p>Requirements:</p><ul><li>show preconfigured limited number of pages at once</li><li>collapse invisible pages under <code>...</code></li><li>provide previous/next navigation buttons</li></ul><h2 id="jinja-templates-for-bootstrap4">Jinja templates for Bootstrap4</h2><p>I've created 3 tier structure of Jinja templates to use Bootstrap4.<br><strong>First</strong> -</p>]]></description><link>http://localhost:2368/flask-pagination-macro/</link><guid isPermaLink="false">5cc492f079d5490c32257553</guid><category><![CDATA[Flask]]></category><dc:creator><![CDATA[Alexey Smirnov]]></dc:creator><pubDate>Thu, 27 Sep 2018 17:35:00 GMT</pubDate><media:content url="http://localhost:2368/content/images/2019/04/Pager-in-hand-684x513.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2019/04/Pager-in-hand-684x513.jpg" alt="Flask pagination macro"><p>In this post I will cover how to create a pagination with Jinja macro feature.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/04/demo.gif" class="kg-image" alt="Flask pagination macro"></figure><!--kg-card-end: image--><p>Requirements:</p><ul><li>show preconfigured limited number of pages at once</li><li>collapse invisible pages under <code>...</code></li><li>provide previous/next navigation buttons</li></ul><h2 id="jinja-templates-for-bootstrap4">Jinja templates for Bootstrap4</h2><p>I've created 3 tier structure of Jinja templates to use Bootstrap4.<br><strong>First</strong> - <code>bootstrap4_base.html</code> - loads css and js files from CDN and defines major blocks:</p><ul><li><code>head</code> - holds content of the <code>&lt;head&gt;</code> tag and defines <code>title</code>, <code>metas</code>, <code>styles</code></li><li><code>body</code> - holds content of the <code>&lt;body&gt;</code> tag and defines <code>navbar</code>, <code>content</code>, <code>scripts</code></li><li><code>navbar</code> - for navigation bar</li><li><code>content</code> - for boostrap container (tag with <code>class="container"</code>)</li><li><code>scripts</code> - goes in the end of the body, <a href="https://stackoverflow.com/questions/383045/is-put-scripts-at-the-bottom-correct">here is why</a></li></ul><p>Blocks may be extended or/and overwritten in the later templates<br>This template follows Bootstrap4 <a href="https://getbootstrap.com/docs/4.0/getting-started/introduction/">intro guide</a></p><p><strong>Second</strong> - <code>page_base.html</code> - creates navbar and extends <code>content</code> block.<br>It shows all the flash messages (the ones invoked with flask <code>flash</code> function) and adds <code>page_content</code>.<br>That one will be extended in the last template and holds actual content.</p><p><strong>Third</strong> - <code>index.html</code> - will overwrite <code>title</code> block and extend <code>page_content</code></p><p>Hierarchy of templates is achieved with using of <code>{% extends "&lt;parent_template.html" %}</code> block to refer to parent template.</p><p>To extend a block - <code>scripts</code> for example - inside child template:</p><!--kg-card-begin: code--><pre><code>{% block scripts %}
    {{ super() }}
    &lt;script&gt;
        alert(1);
    &lt;/script&gt;
(% endblock %)
</code></pre><!--kg-card-end: code--><p>Drop <code>super</code> to just overwrite it.</p><h2 id="jinja-pagination-macro">Jinja pagination macro</h2><p>Macros are comparable with functions in regular programming languages. They are useful to put often used idioms into reusable functions to not repeat yourself (“DRY”).<br>Macro is a bare block that starts with <code>{% macro function_name(formal_params) %}</code>. It holds the HTML, or rather templated Jinja code that will be reused.<br>I'm putting it's code into separate file - <code>_macros.html</code>.</p><p>Usage:</p><ol><li>import it with <code>{% import "_macros.html" as macros %}</code></li><li>call it with <code>{{ macros.function_name(actual_params) }}</code></li></ol><p>Bootstrap pagination follows that <a href="https://getbootstrap.com/docs/4.0/components/pagination/#working-with-icons">doc</a></p><p>I've tried to put as little logic in the macro itself and do all the calculations in the flask view.<br>My version needs 2 params:</p><ol><li><code>endpoint</code> - the name of flask endpoint provided to <code>url_for</code> which builds the actual link to select page</li><li><code>pages</code> list if dictionaries, each one has</li></ol><ul><li><code>class</code> key to define if link is active, normal or disabled</li><li><code>page_label</code> show the page number or navigation icons</li><li><code>href</code> - additional param for <code>url_for</code> which will hold page</li></ul><p>Macro code:</p><!--kg-card-begin: code--><pre><code>{% macro pagination_widget(pages, endpoint) %}
&lt;nav aria-label="Page navigation example"&gt;
    &lt;ul class="pagination"&gt;
        {% for p in pages %}
        &lt;li class="page-item {{p['class']}}"&gt;
            &lt;a href="{{ url_for(endpoint, page = p['href'], **kwargs) }}"
                class="page-link"
                aria-label={{p['page']}}&gt;
                &lt;span aria-hidden="true"&gt;{{p['page_label'] | safe}}&lt;/span&gt;
                &lt;span class="sr-only"&gt;{{p['page_label'] | safe}}&lt;/span&gt;

            &lt;/a&gt;
        &lt;/li&gt;
        {% endfor %}
    &lt;/ul&gt;
&lt;/nav&gt;
{% endmacro %}
</code></pre><!--kg-card-end: code--><h3 id="flask-endpoint">Flask endpoint</h3><p>Endpoint code relies on a <code>Pager</code> class to prepare <code>pages</code>. It first needs to get the page number from URL parameters.  The actual data I'm using is just a list of numbers up to a <code>count</code>. In real world it's going to be a query to the database like <code>SELECT column from table LIMIT Y OFFSET X</code>.<br>Where X - is a page size * current page (zero based), Y - is a page_size.</p><p>OFFSET may be slow with big numbers - it's better to use <a href="https://blog.jooq.org/2013/10/26/faster-sql-paging-with-jooq-using-the-seek-method/">Sleek mode</a></p><p>Flask endpoint:</p><!--kg-card-begin: code--><pre><code>@app.route("/")
def index():
    page = int(request.args.get('page', 1))

    count = 300
    data = range(count)

    pager = Pager(page, count)
    pages = pager.get_pages()

    offset = (page - 1) * current_app.config['PAGE_SIZE']
    limit = current_app.config['PAGE_SIZE']
    data_to_show = data[offset: offset + limit]

    return render_template('index.html', pages=pages, data_to_show=data_to_show)
</code></pre><!--kg-card-end: code--><h3 id="pager-class">Pager class</h3><p>This class prepares a <code>pages</code> list for macro. To do the calculations it needs the number of all items and the current page. Page size and a number of visible pages are read from app config.</p><p>Difficult part was to show exactly predefined number if links to another pages. Invisible pages are collapsed under <code>...</code>.</p><h3 id="app-configuration">App configuration</h3><p>App config contains two parameters:</p><ol><li><code>PAGE_SIZE</code> - how many elements show in a page</li><li><code>VISIBLE_PAGE_COUNT</code> - how may links to pages how in pages inculding <code>...</code>s</li></ol><!--kg-card-begin: code--><pre><code>app = Flask(__name__)
app.secret_key = os.urandom(42)
app.config['PAGE_SIZE'] = 20
app.config['VISIBLE_PAGE_COUNT'] = 10
</code></pre><!--kg-card-end: code--><p>The whole code is available at <a href="https://github.com/smirnov-am/flask-pager">GitHub</a></p><p>Do you have another useful macro? Drop me a message on <a href="https://www.linkedin.com/in/smirnovam/">LinkedIn</a></p>]]></content:encoded></item><item><title><![CDATA[Running Flask in production with Docker]]></title><description><![CDATA[<p>Google top for running Flask with Docker is full of posts where Flask runs in debug mode.<br>That what logs look like when Flask is in development mode:</p><!--kg-card-begin: code--><pre><code> * Serving Flask app "app" (lazy loading)
 * Environment: production
   WARNING: Do not use the development server in a production environment.
   Use a production</code></pre>]]></description><link>http://localhost:2368/running-flask-in-production-with-docker/</link><guid isPermaLink="false">5cc491f679d5490c32257548</guid><category><![CDATA[Flask]]></category><dc:creator><![CDATA[Alexey Smirnov]]></dc:creator><pubDate>Mon, 13 Aug 2018 17:31:00 GMT</pubDate><media:content url="http://localhost:2368/content/images/2019/04/kitflask.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2019/04/kitflask.jpg" alt="Running Flask in production with Docker"><p>Google top for running Flask with Docker is full of posts where Flask runs in debug mode.<br>That what logs look like when Flask is in development mode:</p><!--kg-card-begin: code--><pre><code> * Serving Flask app "app" (lazy loading)
 * Environment: production
   WARNING: Do not use the development server in a production environment.
   Use a production WSGI server instead.
 * Debug mode: on
 * Running on http://0.0.0.0:5555/ (Press CTRL+C to quit)
</code></pre><!--kg-card-end: code--><p>I'd like to make a tutorial on how to run it with uwsgi in Docker using common Docker images.</p><h2 id="flask-app">Flask app</h2><p>I'll take a basic Flask app from it's official <a href="http://flask.pocoo.org/">docs</a></p><!--kg-card-begin: code--><pre><code>from flask import Flask
app = Flask(__name__)

@app.route("/")
def hello():
    return "Hello World!"
</code></pre><!--kg-card-end: code--><p>Naming this file as <code>hello.py</code> and running it with <code>FLASK_APP=test.py flask run --port 5555</code> will yield a warning that development server is used in a production environment like above.</p><h2 id="uwsgi">uwsgi</h2><p>As suggested by the warning we should use <code>uwsgi</code> to run it. For that to happen let's create a uwsgi configuration file named <code>uwsgi.ini</code></p><!--kg-card-begin: code--><pre><code>[uwsgi]
module = hello:app
uid = www-data
gid = www-data
master = true
processes = 5

socket = /tmp/uwsgi.socket
chmod-sock = 664
vacuum = true

die-on-term = true
</code></pre><!--kg-card-end: code--><p>So running uwsgi app with <code>uwsgi --ini uwsgi.ini</code> will give long output indicating that uwsgi started 5 processes (see <code>processes=5</code> in the config). Development server runs only 1 process thus allowing only 1 request at a time. By increasing this number you will increase the number if simultaneous requests to Flask app, but that will require more RAM and there will be more processes with Python interpreter running.</p><p>There is also a backlog for uwsgi meaning that if all workers (uwsgi processes) are busy with requests, excessive requests will be put in a queue of size 100 by default. Requests above that level will be dropped by uwsgi, but we will eventually have nginx in front of it with it's own backlog.</p><!--kg-card-begin: code--><pre><code>[uWSGI] getting INI configuration from uwsgi.ini                                             
*** Starting uWSGI 2.0.17.1 (64bit) on [Fri Aug  3 22:29:18 2018] ***                        
compiled with version: 7.2.0 on 03 August 2018 22:23:17                                      
os: Linux-4.13.0-46-generic #51-Ubuntu SMP Tue Jun 12 12:36:29 UTC 2018                      
nodename: ubuntuvm                                                                                                                                                                           
machine: x86_64                                                                              
clock source: unix                            
detected number of CPU cores: 4               
current working directory: /home/as/Desktop/blog                                    
detected binary path: /home/as/.virtualenvs/blog/bin/uwsgi                          
!!! no internal routing support, rebuild with pcre support !!!                               
your processes number limit is 63569          
your memory page size is 4096 bytes  
detected max file descriptor number: 1024     
lock engine: pthread robust mutexes                                                          
thunder lock: disabled (you can enable it with --thunder-lock)                               
uwsgi socket 0 bound to UNIX address /tmp/uwsgi.socket fd 3                                  
Python version: 3.6.3 (default, Oct  3 2017, 21:45:48)  [GCC 7.2.0]                          
*** Python threads support is disabled. You can enable it with --enable-threads ***          
Python main interpreter initialized at 0x562fb447cb40        i     i         i               
your server socket listen backlog is limited to 100 connections                              
your mercy for graceful operations on workers is 60 seconds                                  
mapped 437520 bytes (427 KB) for 5 cores                                                     
*** Operational MODE: preforking ***                                                         
WSGI app 0 (mountpoint='') ready in 1 seconds on interpreter 0x562fb447cb40 pid: 23917 (default app)                                                                                       
*** uWSGI is running in multiple interpreter mode ***                                        
spawned uWSGI master process (pid: 23917)     
spawned uWSGI worker 1 (pid: 23923, cores: 1) 
spawned uWSGI worker 2 (pid: 23924, cores: 1)                     
spawned uWSGI worker 3 (pid: 23925, cores: 1)                     
spawned uWSGI worker 4 (pid: 23926, cores: 1)                     
spawned uWSGI worker 5 (pid: 23927, cores: 1) 
</code></pre><!--kg-card-end: code--><p>Also this will create a socket file, that will be referred later in nginx configuration.</p><!--kg-card-begin: code--><pre><code>~ ls -la /tmp/uwsgi.socket  
srwxrwxr-x 1 as as 0 aug  3 22:29 /tmp/uwsgi.socket
</code></pre><!--kg-card-end: code--><p>Another thing is the user which runs <code>uwsgi</code> processes and owns a socket. Ideally you need to use user with minimum access right. With <code>uid</code>/<code>gid</code> options I've specified <code>www-data</code> - standard user used by web servers. If you run uwsgi manually from bash it will use your user for socket and processes. But in Docker we will run it as root so these options are needed to downgrade it to <code>www-data</code>.</p><p>Also I've seen that some distributions clean /tmp or some daemons have different view but it's not the case with the base distribution for the image I'm using.</p><p>Uwsgi has a lot of configuration options. There is a good list you need to check if you need to troubleshoot/tune your application that can be found <a href="https://uwsgi-docs.readthedocs.io/en/latest/ThingsToKnow.html">here</a></p><h2 id="nginx">nginx</h2><p>Nginx will serve as a proxy to uwsgi. It's nginx that will listen on ports 80/443 and forward requests to the socket.<br>It's config (named <code>nginx.conf</code>) is pretty straightforward (I'm omitting SSL config)</p><!--kg-card-begin: code--><pre><code>user www-data;
worker_processes auto;
pid /run/nginx.pid;

events {
    worker_connections 1024;
    use epoll;
    multi_accept on;
}

http {
    access_log /dev/stdout;
    error_log /dev/stdout;

    sendfile            on;
    tcp_nopush          on;
    tcp_nodelay         on;
    keepalive_timeout   65;
    types_hash_max_size 2048;

    include             /etc/nginx/mime.types;
    default_type        application/octet-stream;

    index   index.html index.htm;

    server {
        listen       80 default_server;
        listen       [::]:80 default_server;
        server_name  localhost;
        root         /var/www/html;

        location / {
            include uwsgi_params;
            uwsgi_pass unix:/tmp/uwsgi.socket;
        }
    }
}
</code></pre><!--kg-card-end: code--><p>I've added redirection of access and error logs to stdout so both will be accessible through <code>docker logs</code> command. Uwsgi logs are streamed to stdout by default.</p><p>One interesting thing I found is about long lasting requests. Nginx itself may kill these requests. So it's worth adding this config to <code>location</code> block:</p><!--kg-card-begin: code--><pre><code>uwsgi_read_timeout 1h;
uwsgi_send_timeout 1h;
proxy_send_timeout 1h;
proxy_read_timeout 1h;
</code></pre><!--kg-card-end: code--><h2 id="startup-script">Startup script</h2><p>This is a simple startup script that will be used as default for executing container.<br>Name of the file will be <code>start.sh</code> and it will be referred in Dockerfile.</p><!--kg-card-begin: code--><pre><code>#!/usr/bin/env bash
service nginx start
uwsgi --ini uwsgi.ini
</code></pre><!--kg-card-end: code--><h2 id="requirements">requirements</h2><p>Requirements file (<code>requirements.txt</code>) will have only flask and uwsgi and will look like this:</p><!--kg-card-begin: code--><pre><code>click==6.7
Flask==1.0.2
itsdangerous==0.24
Jinja2==2.10
MarkupSafe==1.0
uWSGI==2.0.17.1
Werkzeug==0.14.1
</code></pre><!--kg-card-end: code--><h2 id="dockerfile">Dockerfile</h2><p>I've tried a couple of ready-made images from Docker hub and found them overcomplicated or edited in a way by their maintainers making them unusable. So I'll start with basic python image.</p><!--kg-card-begin: code--><pre><code>FROM python:3.6-slim
</code></pre><!--kg-card-end: code--><p>First thing let's copy <code>hello.py</code>, <code>uwsgi.ini</code>, <code>requirements.txt</code> and <code>start.sh</code> to working directory:</p><!--kg-card-begin: code--><pre><code>COPY . /srv/flask_app
WORKDIR /srv/flask_app
</code></pre><!--kg-card-end: code--><p>Base image doesn't have nginx and some useful packages</p><!--kg-card-begin: code--><pre><code>RUN apt-get clean \
    &amp;&amp; apt-get -y update

RUN apt-get -y install nginx \
    &amp;&amp; apt-get -y install python3-dev \
    &amp;&amp; apt-get -y install build-essential
</code></pre><!--kg-card-end: code--><p>Now let's install python requirements</p><!--kg-card-begin: code--><pre><code>RUN pip install -r requirements.txt --src /usr/local/src
</code></pre><!--kg-card-end: code--><p>Finally, copy nginx config to the proper location, add execution rights to startup script and set is as default.</p><!--kg-card-begin: code--><pre><code>COPY nginx.conf /etc/nginx
RUN chmod +x ./start.sh
CMD ["./start.sh"]
</code></pre><!--kg-card-end: code--><h2 id="building-and-running">Building and running</h2><p>Image build can be done like so:</p><!--kg-card-begin: code--><pre><code>docker build . -t flask_image
</code></pre><!--kg-card-end: code--><p>It creates an image named <code>flask_image</code> that can be run with this command:</p><p><code>docker run --name flask_container -p 80:80 flask_image</code></p><p>Now you may navigate to <a href="http://localhost">http://localhost</a> in you browser to see the output.</p><p>Some useful options when running container</p><ul><li><code>--name</code> gives the container a name that can be found in <code>docker ps</code> output</li><li><code>-p</code> instructs to publish port 80. Second 80 after semicolons tells what port nginx inside the container listens on</li><li><code>-d</code> runs container detached from terminal. Logs then can be viewed by issuing <code>docker logs</code> command</li></ul><h2 id="advantages-of-dockerized-flask">Advantages of dockerized Flask</h2><p>I found it very useful to run Flask like that for a number of reasons:</p><p>Portability: spinning projects on a different machine with different distribution is a piece of cake, provided docker is installed.</p><p>No need to configure process managers (upstart/systemd)</p><p>Automatic restart of failed containers. Just use <code>--restart on-failure</code> with <code>docker run</code></p><p>It's very easy to start with almost serverless AWS ECS Fargate.</p><h2 id="troubleshooting">Troubleshooting</h2><p>When running docker container we specified port 80 so you host should have this port available for docker to bind to on you host. If it's not then change it to something else.</p><p>If your host runs multiple containers they should listen on different ports and some kind if proxy should be running on host OS to direct requests to the proper container.</p><p>To get inside the container issue <code>docker exec -it flask_container /bin/bash</code>. To get the exact container name issue <code>docker ps</code></p><p>To follow error and access logs issue <code>docker logs -f flask_container</code></p><p>How do you run Flask in production? Drop me a message on LinkedIn <a href="https://www.linkedin.com/in/smirnovam/">https://www.linkedin.com/in/smirnovam/</a></p>]]></content:encoded></item><item><title><![CDATA[Securing Flask web applications]]></title><description><![CDATA[<p>I've just recently finished a web security training and in this post I'd like to investigate security mechanisms of my beloved web framework - Flask.<br>I'll go through different types of possible vulnerabilities and the way they can be mitigated.</p><h2 id="xss">XSS</h2><p>Cross-Site Scripting (XSS) attacks are a type of injection,</p>]]></description><link>http://localhost:2368/securing-flask-web-applications/</link><guid isPermaLink="false">5cc490b479d5490c3225752d</guid><category><![CDATA[python]]></category><category><![CDATA[Flask]]></category><category><![CDATA[Security]]></category><dc:creator><![CDATA[Alexey Smirnov]]></dc:creator><pubDate>Wed, 11 Jul 2018 17:26:00 GMT</pubDate><media:content url="http://localhost:2368/content/images/2019/04/flask11.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2019/04/flask11.jpg" alt="Securing Flask web applications"><p>I've just recently finished a web security training and in this post I'd like to investigate security mechanisms of my beloved web framework - Flask.<br>I'll go through different types of possible vulnerabilities and the way they can be mitigated.</p><h2 id="xss">XSS</h2><p>Cross-Site Scripting (XSS) attacks are a type of injection, in which malicious scripts are injected into otherwise benign and trusted websites. <a href="https://www.owasp.org/index.php/Cross-site_Scripting_%28XSS%29">source</a></p><h3 id="exploit">Exploit</h3><p>Consider a form asking for a user input.</p><!--kg-card-begin: code--><pre><code>&lt;form method="post" action="/"&gt;
  &lt;input type="text" name="tweet"&gt;&lt;br&gt;
  &lt;input type="submit"&gt;
&lt;/form&gt;
</code></pre><!--kg-card-end: code--><p>And a template to show tweets by other users where user input from above form passed unprocessed:</p><!--kg-card-begin: code--><pre><code>&lt;title&gt;Hello from flask twitter&lt;/title&gt;
{% for tweet in tweets %}
  &lt;h1 class={{tweet}}&gt;{{ tweet }}!&lt;/h1&gt;
  &lt;a href="{{tweet}}"&gt;Like&lt;/a&gt;
{% endfor %}
</code></pre><!--kg-card-end: code--><p>With the Flask app looking like this:</p><!--kg-card-begin: code--><pre><code>from flask import Flask, request, render_template, make_response
app = Flask(__name__)

tweets = []


@app.route('/', methods=['GET', 'POST'])
def tweet_feed():
    if request.method == 'POST':
        tweet = request.form['tweet']
        tweets.append(tweet)
    return render_template('tweet_feed.html', tweets=tweets)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5005, debug=True)
</code></pre><!--kg-card-end: code--><p>The tweet posted by user will be used as <code>h1</code> class attribute and inside the tag and also as <code>a</code> href attribute.</p><p>A hacker may post malicious code and when another users will open the page with tweets that code may be executed by their browsers:</p><ol><li><code>" onload=alert(1)</code> - if this appears in class attribute it will close the double quote and add a callback to onload event for this DOM.</li><li><code>javascript:alert(1);</code> - if this javascript URI appears in href attribute, browser will execute a code when user clicks.</li><li><code>&lt;script&gt;alert(1)&lt;/script&gt;</code> - if this appears anywhere on the page the script will be executed.</li></ol><p>The script may not just show an alert message, but for example do an AJAX call to another endpoint on this site (i.e. password change).  This allows the attacker to perform any action as the user on this website.</p><h3 id="mitigation">Mitigation</h3><p>When rendering templates Flask configures Jinja2 to automatically escape all values unless explicitly told otherwise. Auto-escaping is not enabled for all templates.<br>The following extensions for templates trigger auto-escaping: .html, .htm, .xml, .xhtml. Templates loaded from a string will have auto-escaping disabled.</p><p>So because of the above exploit using code #3 will be escaped and never executed.</p><p>Code #1 gives me <code>ERR_BLOCKED_BY_XSS_AUDITOR</code> error in Chrome Version 65.0.3325.181. This browser behavior can be manipulated by the server with <code>X-XSS-Protection</code> header <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection">source</a></p><p>The only vulnerable part is href attribute in <code>a</code> tag.<br>We have a following option to mitigate</p><ul><li>do not use user input with <code>href</code></li><li>use <code>{{ url_for('endpoint')}}</code> when rendering template. This has additional benefit of automatically building proper URLs if endpoint path changes.</li><li>use  <code>Content-Security-Policy</code> header in response:</li></ul><!--kg-card-begin: code--><pre><code>@app.route('/', methods=['GET', 'POST'])
def tweet_feed():
    if request.method == 'POST':
        tweet = request.form['tweet']
        tweets.append(tweet)
    response = make_response(render_template('tweet_feed.html', tweets=tweets))
    response.headers['Content-Security-Policy'] = "default-src 'self'"
    return response
</code></pre><!--kg-card-end: code--><p>Content Security Policy (CSP) is security mechanism aimed at protecting from XSS and Clickjacking attacks. CSP allows you to specify trusted origins of loading resources such as Javascript, fonts, CSS and others. And also ban the execution of the built-in Javascript code. <a href="https://web-security.guru/en/web-security/content-security-policy">source</a></p><p><code>default-src 'self'</code> in <code>Content-Security-Policy</code> header in server response instructs browser to load and execute scripts from the same source - your server, which is identified by protocol (http/https), hostname and port triplet. It also disables inline scripts like the one from malicious code #3.</p><p>Another types of XSS are the ones where malicious code is embedded in uploaded file (text, images). I'll address them in File upload section later</p><h2 id="csrf">CSRF</h2><p>Cross-Site Request Forgery is an attack that allows an attacker to make requests to various sites under victim user. If the victim comes to a site containing a malicious code, a request is sent from her username to another service (social network) performing a destructive action.<br>Unlike XSS the malicious code is stored on hacker controlled server where user is tricked to visit.</p><h2 id="exploit-1">Exploit</h2><p>Consider a online bank transfer page. You may access it by logging beforehand with the authentication information stored in cookie files.</p><!--kg-card-begin: code--><pre><code>&lt;!doctype html&gt;
&lt;title&gt;Hello from Flask&lt;/title&gt;
&lt;h1&gt;Account balance {% raw %}${{ balance }}{% endraw %}&lt;/h1&gt;

&lt;h2&gt;New transfer&lt;/h2&gt;
&lt;form method="post" action="/"&gt;
  &lt;input type="text" name="destination_account" placeholder="Destination account"&gt;&lt;br&gt;
  &lt;input type="number" name="amount"&gt;&lt;br&gt;
  &lt;input type="submit" value="Transfer"&gt;
&lt;/form&gt;
</code></pre><!--kg-card-end: code--><p>With Flaks app looking like this:</p><!--kg-card-begin: code--><pre><code>from flask import Flask, request, render_template
app = Flask(__name__)

account_balance = 1000


@app.route('/', methods=['GET', 'POST'])
def transfer():
    global account_balance
    if request.method == 'POST':
        transferred_amount = request.form['amount']
        if transferred_amount.isdigit():
            account_balance -= int(transferred_amount)
    response = make_response(render_template('transfer.html', balance=account_balance))
    return response


if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5005, debug=True)
</code></pre><!--kg-card-end: code--><p>Now an attacker may trick you to follow a link to his website (I'm getting a lot of 'Your transaction is approved, Follow this link for details' spam messages recently).<br>When you follow the link a page with the following script loads:</p><!--kg-card-begin: code--><pre><code>&lt;form method="POST" action="http://0.0.0.0:5005/" id="hacker_form"&gt;
   &lt;input type="text" name="destination_account" value="123123123"/&gt;
   &lt;input type="number" name="amount" value="1000"/&gt;
   &lt;input type="submit" value="Transfer"&gt;
&lt;/form&gt;
&lt;script&gt;document.getElementById("hacker_form").submit()&lt;/script&gt;
</code></pre><!--kg-card-end: code--><p>So when sending this form to bank app at <a href="http://0.0.0.0:5005/">http://0.0.0.0:5005/</a> authorization cookie will be also sent along. Thus user authorized bank to transfer $10000 to Account #123123123</p><h3 id="mitigation-1">Mitigation</h3><p>I've used endpoint that changes the state of account only on POST request. That complicated hacker's task a little bit as he needs user to visit his server with malicious code.<br>If it was just GET user only needs to click the link without loading the script from hacker's server.</p><p>Another security measure is to use tokens with each account state change endpoint.<br>With every form user gets a random token (as a form's hidden field) and when form is POSTed, the token is checked for validity and expiration.<br>In Flask this is implemented in <a href="http://flask-wtf.readthedocs.io/en/stable/">Flask-WTF plugin</a></p><p>Outline</p><ol><li>GET requests should not change the state of the system</li><li>Check <code>Origin</code> and/or <code>Referer</code> request header in server code to match real server name</li><li>Use CSRF-tokens</li></ol><h2 id="sql-injection">SQL Injection</h2><p>SQL Injection occurs when attacker-controlled input is inserted into a SQL query without proper validation or sanitization. This often occurs when using string formatting or concatenation to build queries.<br>An attacker may be able to read data for which they are not authorized, tamper with or destroy data, or possibly even write files or execute code on the database server. The impact is dependent on the exact scenario, but is generally quite severe.</p><h3 id="exploit-2">Exploit</h3><p>Consider bank transfer form from the above example with the following Flask app (I'm using SQLAlchemy here and trying to put things simple, but usually it's not how you manage database session in Flask app)</p><!--kg-card-begin: code--><pre><code>from flask import Flask, request, render_template, make_response, redirect, url_for
from sqlalchemy import Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from sqlalchemy import create_engine

app = Flask(__name__)
Base = declarative_base()
engine = create_engine('sqlite:///123.db', echo=True)

@app.route('/', methods=['GET', 'POST'])
def transfer():
    session = sessionmaker(bind=engine)()
    account_balance_query = session.execute('SELECT balance from accounts WHERE number=1111')
    account_balance = int(account_balance_query.fetchone()[0])
    if request.method == 'POST':
        transferred_amount = request.form['amount']
        destination_account = request.form['destination_account']
        session.execute('UPDATE accounts SET balance = balance - ' + transferred_amount + ' WHERE number=1111')
        session.execute('UPDATE accounts SET balance = balance + ' + transferred_amount + ' WHERE number=' + destination_account)
        session.commit()
        session.close()
        return redirect(url_for('transfer'))
    response = make_response(render_template('transfer.html', balance=account_balance))
    session.close()
    return response

</code></pre><!--kg-card-end: code--><p>I've tried to break all the rules here: building raw queries and concatenating query string with user input directly (I might have used <code>.format</code> as well).<br>So when entering <code>2222;DROP DATABASE;</code> in destination account input field I expected this particular line<br><code>session.execute('UPDATE accounts SET balance = balance + ' + transferred_amount + ' WHERE number=' + destination_account)</code><br>execute an update and then drop database.<br>But it gave me that error <code>sqlite3.Warning: You can only execute one statement at a time.</code> and no changes were made to database.<br>Not all drivers have that protection, while <a href="http://dev.mysql.com/doc/connector-python/en/connector-python-api-mysqlcursor-execute.html">some</a> allow multiple statement to be executed like so.</p><h3 id="mitigation-2">Mitigation</h3><p>The proper way to avoid that is to use ORMs. In that case the Flask app will be like this:</p><!--kg-card-begin: code--><pre><code>from flask import Flask, request, render_template, make_response, redirect, url_for
from sqlalchemy import Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from sqlalchemy import create_engine

app = Flask(__name__)
Base = declarative_base()
engine = create_engine('sqlite:///123.db', echo=True)


class Account(Base):
    __tablename__ = 'accounts'
    id = Column(Integer, primary_key=True, autoincrement=True)
    number = Column(String(64))
    balance = Column(Integer)


@app.route('/', methods=['GET', 'POST'])
def transfer():
    session = sessionmaker(bind=engine)()
    account = session.query(Account).filter_by(number='1111').one()
    if request.method == 'POST':
        transferred_amount = int(request.form['amount'])
        account.balance -= transferred_amount
        destination_account_number = request.form['destination_account']
        destination_account = session.query(Account).filter_by(number=destination_account_number).one()
        destination_account.balance += transferred_amount
        session.commit()
        session.close()
        return redirect(url_for('transfer'))
    session.close()
    response = make_response(render_template('transfer.html', balance=account.balance))
    return response
</code></pre><!--kg-card-end: code--><h2 id="directory-traversal">Directory traversal</h2><p>Directory traversal may happen when for example an attacker uploads a file with a filename like <code>../../../etc/passwd</code>. If he guessed the number of <code>..</code> right he might overwrite the file (given that uwsgi or Flask is running as root, but it may be any other file like <code>~/bash.rc</code>).<br>The mitigation is explained in official Flask docs <a href="http://flask.pocoo.org/docs/1.0/patterns/fileuploads/">here</a></p><p>Essentially you need to sanitize filenames from file upload form. Another advice is avoid using user provided filenames at all and generate your own (hash of the datetime/username/etc) and store them on a separate subdomain (more on it later)</p><h2 id="xss-in-uploaded-files">XSS in uploaded files</h2><p>This is not particularly related to Flask, but malicious javascript might appear not only in reflected output or stored in database (see general XSS attack), but it can also be embedded in images.<br>For example, <a href="https://marcoramilli.blogspot.com/2014/01/hacking-through-image-gif-turn.html">this blog post</a><br>uses that <a href="https://pastebin.com/6yUbfGX5">code</a> to embed javascript in GIF image file. CSP won't help here - so the only way is to serve the images from separate subdomain (that's what actually Facebook does)</p><p>Another thing related to files is how to you actually serve them. A pdf document uploaded by an attacker may have malicious code so if that file is server to another users it's better to add <code>Content-Disposition: attachment</code> header to server response so browser will download it instead of showing right away.</p><h2 id="cookie-protection">Cookie protection</h2><p>Cookie files are used for a lot of things along with storing session or authentication data.<br>There are some methods to protect them from exposing to an attacker</p><h3 id="secure">Secure</h3><p>Cookies are sent with every request in clear text:</p><!--kg-card-begin: code--><pre><code>GET /index.html HTTP/1.1
Host: www.example.org
Cookie: session=XXXXXXX
</code></pre><!--kg-card-end: code--><p>It means that if an attacker that controls network equipment between you and server (or your ISP) can easily read it.<br>Setting cookie <code>secure</code> flag will instruct browser to send a cookie only over protected HTTPS connection.</p><h3 id="http-only">HTTP Only</h3><p><code>HttpOnly</code> flag will instruct browser to hide cookie content from javascript code. In case of XSS attack it will prevent an attacker from accessing sensitive data stored in it.</p><h3 id="samesite">SameSite</h3><p>In the CSRF example the critical part of the attack was that user's cookie was send from attacker controlled site. It can be mitigated by setting <code>SameSite=strict</code>.<br>Another option for that flag is 'lax' which won't allow sending cookies from another sites when doing requests other than <code>GET</code>.</p><p>Flask by default uses <code>session</code> cookie and its flags are set by configuring <code>app</code>:</p><!--kg-card-begin: code--><pre><code>app.config.update(
    SESSION_COOKIE_SECURE=True,
    SESSION_COOKIE_HTTPONLY=True,
    SESSION_COOKIE_SAMESITE='Lax',
)
</code></pre><!--kg-card-end: code--><p>User defined cookies are set with response:</p><!--kg-card-begin: code--><pre><code>response.set_cookie('key', 'value', secure=True, httponly=True, samesite='Lax')
</code></pre><!--kg-card-end: code--><p>Have your Flask apps ever been hacked? Drop me a message on LinkedIn <a href="https://www.linkedin.com/in/smirnovam/">https://www.linkedin.com/in/smirnovam/</a></p>]]></content:encoded></item><item><title><![CDATA[Using NLTK library with AWS Lambda.]]></title><description><![CDATA[<p>I'm going to walk through the process of creating a simple serverless app for finding part-of-speech tag of an input text.</p><h3 id="1-create-virtual-environment">1 Create virtual environment</h3><!--kg-card-begin: code--><pre><code>mac:serverless_nltk as$ mkvirtualenv nltk_env
</code></pre><!--kg-card-end: code--><h3 id="2-install-nltk">2 Install nltk</h3><!--kg-card-begin: code--><pre><code>(nltk_env) mac:serverless_nltk as$ pip install nltk
</code></pre><!--kg-card-end: code--><h3 id="3-download-nltk-data">3 Download nltk data</h3><!--kg-card-begin: code--><pre><code>(nltk_env)</code></pre>]]></description><link>http://localhost:2368/using-nltk-library-with-aws-lambda/</link><guid isPermaLink="false">5cc48fc979d5490c3225751e</guid><category><![CDATA[AWS]]></category><category><![CDATA[NLP]]></category><category><![CDATA[Serverless]]></category><dc:creator><![CDATA[Alexey Smirnov]]></dc:creator><pubDate>Wed, 09 May 2018 17:22:00 GMT</pubDate><media:content url="http://localhost:2368/content/images/2019/04/la.png" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2019/04/la.png" alt="Using NLTK library with AWS Lambda."><p>I'm going to walk through the process of creating a simple serverless app for finding part-of-speech tag of an input text.</p><h3 id="1-create-virtual-environment">1 Create virtual environment</h3><!--kg-card-begin: code--><pre><code>mac:serverless_nltk as$ mkvirtualenv nltk_env
</code></pre><!--kg-card-end: code--><h3 id="2-install-nltk">2 Install nltk</h3><!--kg-card-begin: code--><pre><code>(nltk_env) mac:serverless_nltk as$ pip install nltk
</code></pre><!--kg-card-end: code--><h3 id="3-download-nltk-data">3 Download nltk data</h3><!--kg-card-begin: code--><pre><code>(nltk_env) mac:serverless_nltk as$ python 
Python 3.6.2 (v3.6.2:5fd33b5926, Jul 16 2017, 20:11:06) 
[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import nltk
&gt;&gt;&gt; nltk.download('tagsets')
[nltk_data] Downloading package tagsets to /Users/as/nltk_data...
[nltk_data]   Unzipping help/tagsets.zip.
True
</code></pre><!--kg-card-end: code--><h3 id="4-copy-downloaded-nltk-data-to-current-directory">4 Copy downloaded nltk data to current directory</h3><!--kg-card-begin: code--><pre><code>(nltk_env) mac:serverless_nltk as$ cp -R /Users/as/nltk_data/* ./
</code></pre><!--kg-card-end: code--><h3 id="5-copy-site-packages-from-virtualenv-directory-may-be-checked-with-which-python-">5 Copy site packages from virtualenv directory (may be checked with <code>which python</code>)</h3><!--kg-card-begin: code--><pre><code>(nltk_env) mac:serverless_nltk as$ cp -R /Users/as/.virtualenvs/nltk_env/lib/python3.6/site-packages/* ./
</code></pre><!--kg-card-end: code--><h3 id="6-now-let-s-create-a-lambda-function-code">6 Now let's create a lambda function code</h3><!--kg-card-begin: code--><pre><code>import imp
import sys
# since libsqlite3-dev is not installed in container running lambda
# this workaround of creating dummy empty modules is needed
sys.modules["sqlite"] = imp.new_module("sqlite")
sys.modules["sqlite3.dbapi2"] = imp.new_module("sqlite.dbapi2")
import nltk

from nltk.data import load
tagdict = load('help/tagsets/upenn_tagset.pickle')

def lambda_handler(event, context):
    text = event.get('text')
    tokenized = nltk.word_tokenize(text)
    tagged = nltk.pos_tag(tokenized)
    return {word: tagdict[tag][0] for word, tag in tagged}

</code></pre><!--kg-card-end: code--><h3 id="7-let-s-check-the-size-">7 Let's check the size.</h3><!--kg-card-begin: code--><pre><code>(nltk_env) mac:serverless_nltk as$ du -sh ./ | cut -f1
187M
</code></pre><!--kg-card-end: code--><h3 id="8-zip-everything">8 Zip everything</h3><!--kg-card-begin: code--><pre><code>(nltk_env) mac:serverless_nltk as$ zip -r -9 -q ./lambda.zip *
</code></pre><!--kg-card-end: code--><h3 id="9-upload-to-s3">9 Upload to S3</h3><!--kg-card-begin: code--><pre><code>(nltk_env) mac:serverless_nltk as$ aws s3 mb s3://serverless-nltk
(nltk_env) mac:serverless_nltk as$ aws s3 cp ./lambda.zip s3://serverless-nltk
</code></pre><!--kg-card-end: code--><h3 id="10-create-lambda">10 Create lambda</h3><!--kg-card-begin: code--><pre><code>(nltk_env) mac:serverless_nltk as$ aws lambda create-function \
                                            --function-name serverless-nltk \
                                            --runtime  python3.6 \
                                            --role arn:aws:iam::1234567890:role/lambda_basic_execution \
                                            --handler lambda_function.lambda_handler --code S3Bucket=serverless-nltk,S3Key=lambda2.zip \
                                            --environment Variables={NLTK_DATA=./} 
</code></pre><!--kg-card-end: code--><p>Key things here are</p><ul><li>role arn can be found in IAM (look for role with name <code>lambda_basic_execution</code>)</li><li>environment should create an environment variable telling nltk where look for data</li></ul><p>Now let's create a simple javascript application that will call lambda with user input from the page:</p><ol><li>Go to AWS Cognito</li><li>Create a new identity pool</li><li>In the first step check <code>Enable access to unauthenticated identities</code></li><li>In the <code>sample code</code> step select javascript and copy <code>IdentityPoolId</code> (needed in invocation script later)</li><li>Go to IAM</li><li>Find the role for unauthenticated access (it will look like <code>Cognito_serverless_nltkUnauth_Role</code>)</li><li>Select <code>Permission</code> and edit the role as json. It should look like this</li></ol><!--kg-card-begin: code--><pre><code>{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": [
                "mobileanalytics:PutEvents",
                "cognito-sync:*"
            ],
            "Resource": [
                "*"
            ]
        },
        {
            "Effect": "Allow",
            "Action": [
                "lambda:InvokeFunction"
            ],
            "Resource": [
                "arn:aws:lambda:us-east-1:1234567890:function:serverless-nltk"
            ]
        }
    ]
}
</code></pre><!--kg-card-end: code--><p>The script calling the lambda will look like this</p><!--kg-card-begin: code--><pre><code>&lt;script type="text/javascript"&gt;
    var button = document.getElementById('upload-button');
    AWS.config.credentials = new AWS.CognitoIdentityCredentials({IdentityPoolId: 'us-east-1:8b6a0b3d-6a2a-4c7d-b617-c8dafd8a1aec'});
    AWS.config.region = 'us-east-1';
    var lambda = new AWS.Lambda({region: 'us-east-1', apiVersion: '2015-03-31'});
    
    function htmlToElement(html) {
        var template = document.createElement('template');
        html = html.trim(); // Never return a text node of whitespace as the result
        template.innerHTML = html;
        return template.content.firstChild;
    }
    
    function call_lambda() { 
            var pullParams = {
                FunctionName : 'serverless-nltk',
                InvocationType : 'RequestResponse',
                LogType : 'None',
                Payload : JSON.stringify({text:document.getElementById("exampleFormControlTextarea1").value})
            };
            // create variable to hold data returned by the Lambda function
            var pullResults;
            lambda.invoke(pullParams, function(error, data) {
            if (error) {
                console.log(error);

            } else {
                pullResults = JSON.parse(data.Payload);
                console.log(pullResults);
                var result = document.getElementById("result")
                result.innerHTML = '';
                for (var key in pullResults) 
                {
                    var text = htmlToElement('&lt;span&gt;'+key+':&amp;nbsp;&lt;/span&gt;');
                    var pos = htmlToElement('&lt;span&gt;'+pullResults[key]+ '&lt;/span&gt;');
                    var line = htmlToElement('&lt;h6&gt;&lt;/h6&gt;');
                    line.appendChild(text);
                    line.appendChild(pos);
                    result.appendChild(line);
                }
            }
            });
    }; 
&lt;/script&gt;
</code></pre><!--kg-card-end: code--><p>The resulting app can be accessed <a href="http://serverless-nltk.s3-website-us-east-1.amazonaws.com/">here</a></p>]]></content:encoded></item><item><title><![CDATA[Extracting keyphrases from texts: unsupervised algorithm TopicRank]]></title><description><![CDATA[<p>Keyphrase extraction is the task of identifying single or multi-word expressions that represent the main topics of a document.<br>There are 2 approaches to extract topics (and/or keyphrases) from a text: supervised and unsupervised.</p><h3 id="supervised-approach">Supervised approach</h3><p>This is a multi-label, multi-class classification algorithm, where we may have following features</p>]]></description><link>http://localhost:2368/extracting-keyphrases-from-texts-unsupervised-algorithm-topicrank/</link><guid isPermaLink="false">5cc48eb579d5490c32257506</guid><category><![CDATA[machine learning]]></category><category><![CDATA[NLP]]></category><category><![CDATA[python]]></category><dc:creator><![CDATA[Alexey Smirnov]]></dc:creator><pubDate>Mon, 16 Apr 2018 17:17:00 GMT</pubDate><media:content url="http://localhost:2368/content/images/2019/04/words-bg.png" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2019/04/words-bg.png" alt="Extracting keyphrases from texts: unsupervised algorithm TopicRank"><p>Keyphrase extraction is the task of identifying single or multi-word expressions that represent the main topics of a document.<br>There are 2 approaches to extract topics (and/or keyphrases) from a text: supervised and unsupervised.</p><h3 id="supervised-approach">Supervised approach</h3><p>This is a multi-label, multi-class classification algorithm, where we may have following features as an input:</p><ul><li>text converted to <a href="https://en.wikipedia.org/wiki/Bag-of-words_model">bag-of-words</a></li><li>text is treated as a stream of vectors, which are pre-trained <a href="https://en.wikipedia.org/wiki/Word_embedding">word embeddings</a></li></ul><p>For bag-of-words we may use <a href="http://scikit-learn.org/stable/tutorial/text_analytics/working_with_text_data.html#evaluation-of-the-performance-on-the-test-set">linear SVM</a> as a classifier.<br>For word embeddings RNN are a <a href="http://colah.github.io/posts/2014-07-NLP-RNNs-Representations/">better fit</a></p><p>Later, when the model is trained it may be used to classify unseen text.</p><p>Limitations:</p><ul><li>large amount of data is needed to train classifiers</li><li>training dataset should be labeled</li><li>labels/topics are predefined</li><li>RNN-LTSM are slow</li></ul><p>Advantages:</p><ul><li>good accuracy</li><li>extracted entities are not keyphrases from the text itself, but more general topics</li></ul><h3 id="unsupervised-learning">Unsupervised learning</h3><p><a href="http://www.aclweb.org/anthology/I13-1062">Adrien Bougouin</a> proposed a method to extract keyphrases that represent topics of the document without prior model training.</p><p>I've tried to implement his algorithm <a href="https://github.com/smirnov-am/pytopicrank">here</a> which goes like this:</p><ul><li>tokenize text and identify part-of-speech of each token</li><li>identify longest sequences of adjectives and nouns - they constitute keyphrases</li><li>convert each keyphrase to term frequency vector using bag of words, apply stemmer for better compression</li><li>find clusters of keyphrases using Hierarchical Agglomerative Clustering (HAC) algorithm to form topics:</li><li>use average strategy</li><li>identify cluster by max depth of 0.74 (good explanation if HAC can be found <a href="https://joernhees.de/blog/2015/08/26/scipy-hierarchical-clustering-and-dendrogram-tutorial/#Selecting-a-Distance-Cut-Off-aka-Determining-the-Number-of-Clusters">here</a></li><li>use clusters as graph vertices and sum of distances between each keyphare of topic pairs as edge weight</li><li>apply PageRank to identify most prominent topics (implemented in <code>networkx</code>)</li></ul><p>For topN topics extract most significant keyphrases that represent this topic. Possible strategies:</p><ul><li>use a keyphrase which is closer to the beginning of the text</li><li>use center of the cluster from p.4</li><li>use most frequent</li></ul><p>Limitations:</p><ul><li>topics are represented by words from the text itself</li></ul><p>Advantages:</p><ul><li>fast</li><li>no training needed</li><li>unlike <a href="http://blog.echen.me/2011/08/22/introduction-to-latent-dirichlet-allocation/">LDA</a> topics are easily interpreted by humans</li></ul><h2 id="tests">Tests</h2><p>Let's try to analyze key phrases of original article on TopicsRank.<br>Top10 keyphrases are: <code>document</code>, <code>topics</code>, <code>keyphrase</code>, <code>graph</code>, <code>metshod</code>, <code>topicrank</code>, <code>word</code>, <code>vertices</code> <code>keyphrase candidate</code>, <code>datasets</code>, which is pretty close to what article is about.</p><h2 id="deployment">Deployment</h2><p>I've deployed my implementation of TopicRank as a AWS Lambda function that is being invoked from JavaScript directly <a href="http://pytopicrank.s3-website-us-east-1.amazonaws.com/">here</a> (I've set <code>max_d=1.25</code> there for no particular reason so results may vary)</p>]]></content:encoded></item><item><title><![CDATA[E-commerce recommendation systems: basket analysis. Performance comparison of most common algorithms.]]></title><description><![CDATA[<p>Once novelty recommendation systems are used now by more and more e-commerce sites to help customers find products to purchase. For e-commerce business owners these tools facilitate cross-sales.</p><h2 id="usage">Usage</h2><p>Amazon is one of the most prominent organizations used recommendations to increase sales.<br>According to <a href="http://fortune.com/2012/07/30/amazons-recommendation-secret/">fortune.com</a> Amazon was able to</p>]]></description><link>http://localhost:2368/2018-04-08-e-commerce-recommendation-systems-html/</link><guid isPermaLink="false">5cc4643e79d5490c322574e2</guid><category><![CDATA[machine learning]]></category><category><![CDATA[python]]></category><dc:creator><![CDATA[Alexey Smirnov]]></dc:creator><pubDate>Sun, 08 Apr 2018 14:18:00 GMT</pubDate><media:content url="http://localhost:2368/content/images/2019/04/2019-04-27-19.14.23.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2019/04/2019-04-27-19.14.23.jpg" alt="E-commerce recommendation systems: basket analysis. Performance comparison of most common algorithms."><p>Once novelty recommendation systems are used now by more and more e-commerce sites to help customers find products to purchase. For e-commerce business owners these tools facilitate cross-sales.</p><h2 id="usage">Usage</h2><p>Amazon is one of the most prominent organizations used recommendations to increase sales.<br>According to <a href="http://fortune.com/2012/07/30/amazons-recommendation-secret/">fortune.com</a> Amazon was able to increase sales by 29% in 2012 as a result of implementing recommendation system.<br>35% of Amazon’s revenue is generated by its recommendation engine <a href="https://www.mckinsey.com/industries/retail/our-insights/how-retailers-can-keep-up-with-consumers">(source)</a>.</p><p>Amazon is using <a href="https://www.computer.org/csdl/mags/ic/2017/03/mic2017030012.html">collaborative filtering approach</a></p><p>However there is another approach to mine items that a frequently bought together - <strong>association rule mining</strong>.</p><p>The difference is the unit of aggregation: collaborative filtering unit is user or items.</p><p>With user-to-user collaborative filtering approach algorithm finds a user which similar to you and suggests to buy the same he  bought. This is computationally difficult as there might be more users than items or users have very dissimilar interests.</p><p>With item-to-item collaborative filtering approach which is used by Amazon, algorithm finds a neighborhood of items that are bought/viewed by you and users that bought viewed the same item. Then items from that neighborhood are displayed as recommendations.</p><p>Association rule unit is a session (order), which makes this approach less personalized, as users and user purchase history is not taken into account.<br>But it has some strong points:</p><ul><li>it’s extremely simple and fast.</li><li>it will work with very small and sparse customer bases.</li><li>knowledge of the customer beyond what products or services they currently have is not necessary.</li></ul><p>However, there is one major drawback that makes association rule algorithms less favored by e-commerce - inability to catch so called "long tail". As online stores have a lot of items and some of them are bought rarely. But among these rare items there might be a pair that are of interested to specific group of people. Association rules are unlikely to finds them.</p><p>But these algorithms are useful for offline stores, where it's not possible to track users and find application in other areas.</p><h2 id="algorithms">Algorithms</h2><p><a href="http://www.vldb.org/conf/1994/P487.PDF"><strong>Apriori</strong></a>: it was introduced in 1993 , more than 20 years ago. It remains one of the most important data mining algorithms, not because it is the fastest, but because it has influenced the development of many other algorithms <a href="http://data-mining.philippe-fournier-viger.com/classic-data-mining-algorithm-1-apriori/">(source)</a></p><p><strong>Apriori-TID</strong>: is a variation of the Apriori algorithm. It was proposed in the same article as Apriori as an alternative implementation. It produces the same output, but does less scans<br>of the transaction database</p><p><a href="https://www.slideshare.net/deepa15/eclat-37310304"><strong>Eclat</strong></a>: is faster than Apriori, but less memory efficient</p><p><a href="http://dx.doi.org/10.1145/335191.335372"><strong>FP-Growth</strong></a>: most advanced and efficient implementation of frequent pattern mining</p><h2 id="input-parameters">Input parameters</h2><ul><li><em>order list</em>: database of all orders (transactions). Each entry is a subset of all items that are being sold (here item count is dropped)</li></ul><p>Example:</p><!--kg-card-begin: code--><pre><code>1 {item1, item3, item4}
2 {item2, item3, item5}
3 {item1, item2, item3, item5}
4 {item2, item5}
</code></pre><!--kg-card-end: code--><ul><li><em>list of all possible items on sale</em>: optional parameter that can determined by scanning order list once</li></ul><p>Example: <code>items = {item1, item2, item3, item4, item5}</code></p><ul><li><em>minimum support</em>: minimum frequency for an item or itemset to count as frequent</li></ul><p>Example: <code>min_support=0.1</code> means that we are interested in items or itemsets that appeared in minimum 10% of all orders</p><ul><li><em>minimum confidence</em>: parameter that says how likely item Y is purchased when item X is purchased, expressed as {X -&gt; Y}. This is measured by the proportion of transactions with item X, in which item Y also appears</li></ul><p>This can be calculated like so <code>confidence({X -&gt; Y}) = support({X, Y}) / support(X)</code></p><ul><li><em>minimum lift</em> (optional as not used in many implementations): parameter that says how likely item Y is purchased when item X is purchased,<br>while controlling for how popular item Y is. A lift value greater than 1 means that item Y is likely to be bought if item X is bought, while a value less than 1 means that item Y is unlikely to be bought if item X is bought</li></ul><p>Formula for lift is <code>lift({X -&gt; Y}) = support({X, Y}) / (support(X) * support(Y))</code></p><h2 id="output-">Output:</h2><p>A list of rules in a form (<code>from_itemset</code>, <code>to_itemset</code>, <code>confidence</code>, <code>lift</code>), where <code>from_itemset</code> and <code>to_itemset</code> are subsets of items on sale.</p><h2 id="making-a-recommendation">Making a recommendation</h2><p>Recommendation can be made, for example at a checkout, when user has item1 and item2 in the shopping cart. In that case <code>from_itemset = {item1, item2}</code> and using the list of rules we may find respective<br><code>to_itemset</code> with maximum confidence and/or lift.</p><h2 id="apriori-algorithm-">Apriori algorithm.</h2><h3 id="1st-step-">1st step:</h3><p>Let the <code>candidates_1</code> set to contain all individual items.</p><p>Now let's calculate support for each <code>candidate</code> in <code>candidates_1</code>.</p><p>Populate <code>layer_1</code> set with those candidates, which support is &gt;= <code>min_support</code></p><h3 id="2nd-step-">2nd step:</h3><p>Let the <code>candidates_2</code> be populated with all pairs from <code>layer_1</code></p><p>For example, if <code>layer_1 = {item1, item3, item4}</code></p><p>then <code>candidates_2 = [{item1, item3}, {item1, item4}, {item3, item4}]</code></p><p>Now let's calculate support for each <code>candidate</code> in <code>candidates_2</code> as in previous step by going through each order in order list.<br>Populate <code>layer_2</code> with those candidates from <code>candidates_2</code>, which support is &gt;= <code>min_support</code></p><h3 id="nth-step-">Nth step:</h3><p>Repeat step 2 until you can form candidates sets. Candidates for a next step are formed from a layer of a current step by unions of all possible pairs in layer set (elements of a layer should be sets to support this). This is also known as self-join.<br>Now we have filtered set of combinations of items and their respective support (support dictionary).</p><p>In each step we populate a support dictionary using itemsets as keys and their correspondent support as values.</p><h3 id="association-rules">Association rules</h3><p>Next step is to calculate all association rules.<br>Let's fix a hyper-parameters <code>min_confidence</code> and <code>min_lift</code>.</p><p>For all sets <code>L</code> in support dictionary let's create all non-empty subsets <code>S</code> of <code>L</code>, and evaluate confidence and lift for a rule <code>{S -&gt; L-S}</code> and save rules, whose parameters are greater of equal then minimal.</p><p><em>In a notion {X -&gt; Y}, X is called from-itemset, and Y - to-itemset.</em></p><h2 id="apriori-tid">Apriori-TID</h2><ul><li>the order list is not used at all for counting the support of candidate itemsets after the first pass.</li><li>the candidate itemsets are generated the same way as in Apriori algorithm</li><li>rules are generated the same way after support dictionary is populated<br>The only different is that in each layer &gt; 1 a separate list C' is created.<br>C' hold transaction ids with corresponding itemsets from candidates on that layer that are in that particular transaction.</li></ul><p>For example, using order list from above first layer would yield such support dictionary:</p><!--kg-card-begin: code--><pre><code>item1 0.5
item2 0.75
item3 0.75 
item5 0.75
</code></pre><!--kg-card-end: code--><p>Second layer candidates set is:</p><!--kg-card-begin: code--><pre><code>{item1, item2} 0.25
{item1, item3} 0.5 *
{item1, item5} 0.25
{item2, item3} 0.5 *
{item2, item5} 0.75 *
{item3, item5} 0.5 *
</code></pre><!--kg-card-end: code--><p>So <code>layer_2</code> will consist from itemsets with <code>*</code>. And at this step we create a separate data structure to hold transaction IDs for these sets that made it to <code>layer_2</code></p><!--kg-card-begin: code--><pre><code>1 {item1, item3}
2 {item2, item3} {item2, item5} {item3, item5}
3 {item1, item2} {item1, item3} {item1, item5} {item2, item3} {item2, item5} {item3, item5}
4 {item2, item5}
</code></pre><!--kg-card-end: code--><p>Using this additional list we will calculate support for candidates for <code>layer_3</code>.</p><h2 id="eclat">Eclat</h2><p>Another way to speedup support calculation is to keep a list of transaction ids for every itemset at each layer. It speeds up support calculation even more, but these transaction lists can be large in size.</p><p>Again using the same order list in first step, transaction ID list will be</p><!--kg-card-begin: code--><pre><code>item1 1, 3
item2 2, 3, 4
item3 1, 2, 3
item4 1
item5 2, 3, 4
</code></pre><!--kg-card-end: code--><p>item4 won't be included in the next layer, and this list can help us to calculate lists for all possible pairs for the next step:</p><!--kg-card-begin: code--><pre><code>{item1 item2} 3
{item1 item3} 1, 3
{item1 item4} 1
{item1 item5} 3
{item2 item3} 2, 3
...etc
</code></pre><!--kg-card-end: code--><h2 id="fp-growth">FP-Growth</h2><p>This one is different from Apriori-like algorithms in a way that candidate itemsets are not generated explicitly. FP-growth uses a suffix tree (FP-tree) structure to encode transactions thus speeds up support calculation.</p><h2 id="tests">Tests</h2><p>Dataset was taken from <a href="http://archive.ics.uci.edu/ml/datasets/Online+Retail">http://archive.ics.uci.edu/ml/datasets/Online+Retail</a> <em>Daqing Chen, Sai Liang Sain, and Kun Guo, Data mining for the online retail industry: A case study of RFM model-based customer segmentation using data mining, Journal of Database Marketing and Customer Strategy Management, Vol. 19, No. 3, pp. 197â€“208, 2012 (Published online before print: 27 August 2012. doi: 10.1057/dbm.2012.17).</em></p><h3 id="preprocessing">Preprocessing</h3><p>As each row contains <code>InvoiceNo</code> and <code>StockCode</code>, let's group items by <code>InvoiceNo</code></p><!--kg-card-begin: code--><pre><code>import csv
from collections import defaultdict

order_list = defaultdict(list)

with open('data.csv', encoding="iso-8859-1") as f:
    csv_reader = csv.DictReader(f)
    for row in csv_reader:
        order_list[row['InvoiceNo']].append(row['StockCode'])
</code></pre><!--kg-card-end: code--><p>Some stats of the dataset:</p><ul><li>number of orders: 25900</li><li>4070 items on sale</li><li>minimum order: 1 item</li><li>maximum order: 1114 items</li><li>mean order size: ~21 items</li></ul><h3 id="python-implementation">Python implementation</h3><p>I've implemented all 4 aforementioned algorithms <a href="https://github.com/smirnov-am/pyfreqpm">here</a>.<br>FP-Growth needs some more testing though, so I've used <a href="https://spark.apache.org/docs/2.3.0/mllib-frequent-pattern-mining.html">Apache Spark</a></p><p>Running times with <code>min_support=0.03</code>, <code>min_confidence=0.5</code>, <code>min_lift=1.0</code> are:</p><p>Algorithmrun time, smemmory used, MBapriori-gen21050apriori-tid35202eclat*8000fp-growth8</p><p>* Eclat generated long id lists and it depleted 8GB RAM very fast in my docker container, so I never ended this test.</p><h3 id="generated-rules">Generated rules</h3><p>All algorithms showed same 3 rules, with 2nd and 3rd being the same pair.</p><p>from_itemsetto_itemsetconfidencelift2238685099B0.678.222697226990.7417.122699226970.717.1</p><p>22386 = JUMBO BAG PINK POLKADOT</p><p>85099B = JUMBO BAG RED RETROSPOT</p><p>22697 = GREEN REGENCY TEACUP AND SAUCER</p><p>22699 = ROSES REGENCY TEACUP AND SAUCER</p><p>Not very impressive findings, so it worth trying to experiment with different input parameters.<br>But based on them we can recommend someone buying "JUMBO BAG PINK POLKADOT" to get a "JUMBO BAG RED RETROSPOT" as well. Same goes for teacups.</p><h2 id="another-usages-of-frequent-pattern-mining">Another usages of frequent pattern mining</h2><p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.300.4808&amp;rep=rep1&amp;type=pdf">Network traffic</a></p><p><a href="http://www.ijeert.org/pdf/v3-i10/9.pdf">Web pages</a></p><p><a href="https://pdfs.semanticscholar.org/5662/e754f611c34c01e3126c3df63a4ce6e78cb3.pdf">Image classification</a></p><p><a href="https://academic.oup.com/bib/article/16/2/216/245744">Bio informatics</a></p><p>What approach for recommendation system are you using? Drop me a message on LinkedIn <a href="https://www.linkedin.com/in/smirnovam/">https://www.linkedin.com/in/smirnovam/</a></p>]]></content:encoded></item></channel></rss>