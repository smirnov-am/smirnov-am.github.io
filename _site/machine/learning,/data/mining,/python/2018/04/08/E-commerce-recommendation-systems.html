<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.4.0 -->
<title>E-commerce recommendation systems | Alexey Smirnov</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="E-commerce recommendation systems" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Once novelty recommendation systems are used now by more and more e-commerce sites to help customers find products to purchase. For e-commerce business owners these tools facilitate cross-sales." />
<meta property="og:description" content="Once novelty recommendation systems are used now by more and more e-commerce sites to help customers find products to purchase. For e-commerce business owners these tools facilitate cross-sales." />
<link rel="canonical" href="http://localhost:4000/machine/learning,/data/mining,/python/2018/04/08/E-commerce-recommendation-systems.html" />
<meta property="og:url" content="http://localhost:4000/machine/learning,/data/mining,/python/2018/04/08/E-commerce-recommendation-systems.html" />
<meta property="og:site_name" content="Alexey Smirnov" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-04-08T23:01:34+02:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/machine/learning,/data/mining,/python/2018/04/08/E-commerce-recommendation-systems.html","description":"Once novelty recommendation systems are used now by more and more e-commerce sites to help customers find products to purchase. For e-commerce business owners these tools facilitate cross-sales.","headline":"E-commerce recommendation systems","datePublished":"2018-04-08T23:01:34+02:00","dateModified":"2018-04-08T23:01:34+02:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/machine/learning,/data/mining,/python/2018/04/08/E-commerce-recommendation-systems.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Alexey Smirnov" /></head>
<body><header class="site-header" role="banner">

    <div class="wrapper"><a class="site-title" rel="author" href="/">Alexey Smirnov</a><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger" />
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewBox="0 0 18 15" width="18px" height="15px">
                <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
                <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
                <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
              </svg>
            </span>
          </label>
  
          <div class="trigger"><a class="page-link" href="https://www.linkedin.com/in/smirnovam/">Linkedin</a>
          <a class="page-link" href="https://github.com/smirnov-am">GitHub</a></div>
        </nav></div>
  </header><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">E-commerce recommendation systems</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-04-08T23:01:34+02:00" itemprop="datePublished">Apr 8, 2018
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Once novelty recommendation systems are used now by more and more e-commerce sites to help customers find products to purchase. For e-commerce business owners these tools facilitate cross-sales.</p>

<h2 id="usage">Usage</h2>
<p>Amazon is one of the most prominent organizations used recommendations to increase sales.
According to <a href="http://fortune.com/2012/07/30/amazons-recommendation-secret/">fortune.com</a> Amazon was able to increase sales by 29% in 2012 as a result of implementing recommendation system. 
35% of Amazom’s revenue is generated by its recommendation engine <a href="https://www.mckinsey.com/industries/retail/our-insights/how-retailers-can-keep-up-with-consumers">(source)</a>.</p>

<p>Amazon is using <a href="https://www.computer.org/csdl/mags/ic/2017/03/mic2017030012.html">collaborative filtering approach</a></p>

<p>However there is another approach to mine items that a frequently bought together - <strong>association rule mining</strong>.</p>

<p>The difference is the unit of aggregation: collaborative filtering unit is user or items.</p>

<p>With user-to-user collaborative filtering approach algorithm finds a user which similar to you and suggests to buy the same he  bought. This is computationally difficult as there might be more users than items or users have very dissimilar interests.</p>

<p>With item-to-item collaborative filtering approach which is used by Amazon, algorithm finds a neighborhood of items that are bought/viewed by you and users that bought viewed the same item. Then items from that neighborhood are displayed as recommendations.</p>

<p>Association rule unit is a session (order), which makes this approach less personalized, as users and user purchase history is not taken into account.
But it has some strong points:</p>
<ul>
  <li>it’s extremely simple and fast.</li>
  <li>it will work with very small and sparse customer bases.</li>
  <li>knowledge of the customer beyond what products or services they currently have is not necessary.</li>
</ul>

<p>However, there is one major drawback that makes association rule algorithms less favored by e-commerce - inability to catch so called “long tail”. As online stores have a lot of items and some of them are bought rarely. But among these rare items there might be a pair that are of interested to specific group of people. Association rules are unlikely to finds them.</p>

<p>But these algorithms are useful for offline stores, where it’s not possible to track users and find application in other areas.</p>

<h2 id="algorithms">Algorithms</h2>

<ul>
  <li>
    <p><a href="http://www.vldb.org/conf/1994/P487.PDF"><strong>Apriori</strong></a>: it was introduced in 1993 , more than 20 years ago. It remains one of the most important data mining algorithms, not because it is the fastest, but because it has influenced the development of many other algorithms <a href="http://data-mining.philippe-fournier-viger.com/classic-data-mining-algorithm-1-apriori/">(source)</a></p>
  </li>
  <li>
    <p><strong>Apriori-TID</strong>: is a variation of the Apriori algorithm. It was proposed in the same article as Apriori as an alternative implementation. It produces the same output, but does less scans 
of the transaction database</p>
  </li>
  <li><a href="https://www.slideshare.net/deepa15/eclat-37310304"><strong>Eclat</strong></a>: is faster than Apriori, but less memory efficient</li>
  <li><a href="http://dx.doi.org/10.1145/335191.335372"><strong>FP-Growth</strong></a>: most advanced and efficient implementation of frequent pattern mining</li>
</ul>

<h2 id="input-parameters">Input parameters</h2>
<ul>
  <li><em>order list</em>: database of all orders (transactions). Each entry is a subset of all items that are being sold (here item count is dropped)</li>
</ul>

<blockquote>
  <p>Example:</p>
</blockquote>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 {item1, item3, item4}
2 {item2, item3, item5}
3 {item1, item2, item3, item5}
4 {item2, item5}
</code></pre></div></div>

<ul>
  <li><em>list of all possible items on sale</em>: optional parameter that can determined by scanning order list once</li>
</ul>

<blockquote>
  <p>Example: <code class="highlighter-rouge">items = {item1, item2, item3, item4, item5}</code></p>
</blockquote>

<ul>
  <li><em>minimum support</em>: minimum frequency for an item or itemset to count as frequent</li>
</ul>

<blockquote>
  <p>Example: <code class="highlighter-rouge">min_support=0.1</code> means that we are interested in items or itemsets that appeared in minimum 10% of all orders</p>
</blockquote>

<ul>
  <li><em>minimum confidence</em>: parameter that says how likely item Y is purchased when item X is purchased, expressed as {X -&gt; Y}. This is measured by the proportion of transactions with item X, in which item Y also appears</li>
</ul>

<blockquote>
  <p>This can be calculated like so <code class="highlighter-rouge">confidence({X -&gt; Y}) = support({X, Y}) / support(X)</code></p>
</blockquote>

<ul>
  <li><em>minimum lift</em> (optional as not used in many implementations): parameter that says how likely item Y is purchased when item X is purchased,
while controlling for how popular item Y is. A lift value greater than 1 means that item Y is likely to be bought if item X is bought, while a value less than 1 means that item Y is unlikely to be bought if item X is bought</li>
</ul>

<blockquote>
  <p>Formula for lift is <code class="highlighter-rouge">lift({X -&gt; Y}) = support({X, Y}) / (support(X) * support(Y))</code></p>
</blockquote>

<h2 id="output">Output:</h2>
<p>A list of rules in a form (<code class="highlighter-rouge">from_itemset</code>, <code class="highlighter-rouge">to_itemset</code>, <code class="highlighter-rouge">confidence</code>, <code class="highlighter-rouge">lift</code>), where <code class="highlighter-rouge">from_itemset</code> and <code class="highlighter-rouge">to_itemset</code> are subsets of items on sale.</p>

<h2 id="making-a-recommendation">Making a recommendation</h2>

<p>Recommendation can be made, for example at a checkout, when user has item1 and item2 in the shopping cart. In that case <code class="highlighter-rouge">from_itemset = {item1, item2}</code> and using the list of rules we may find respective
<code class="highlighter-rouge">to_itemset</code> with maximum confidence and/or lift.</p>

<h2 id="apriori-algorithm">Apriori algorithm.</h2>
<h3 id="1st-step">1st step:</h3>
<p>Let the <code class="highlighter-rouge">candidates_1</code> set to contain all individual items.</p>

<p>Now let’s calculate support for each <code class="highlighter-rouge">candidate</code> in <code class="highlighter-rouge">candidates_1</code>.</p>

<p>Populate <code class="highlighter-rouge">layer_1</code> set with those candidates, which support is &gt;= <code class="highlighter-rouge">min_support</code></p>

<h3 id="2nd-step">2nd step:</h3>
<p>Let the <code class="highlighter-rouge">candidates_2</code> be populated with all pairs from <code class="highlighter-rouge">layer_1</code></p>

<blockquote>
  <p>For example, if <code class="highlighter-rouge">layer_1 = {item1, item3, item4}</code></p>

  <p>then <code class="highlighter-rouge">candidates_2 = [{item1, item3}, {item1, item4}, {item3, item4}]</code></p>
</blockquote>

<p>Now let’s calculate support for each <code class="highlighter-rouge">candidate</code> in <code class="highlighter-rouge">candidates_2</code> as in previous step by going through each order in order list.
Populate <code class="highlighter-rouge">layer_2</code> with those candidates from <code class="highlighter-rouge">candidates_2</code>, which support is &gt;= <code class="highlighter-rouge">min_support</code></p>

<h3 id="nth-step">Nth step:</h3>
<p>Repeat step 2 until you can form candidates sets. Candidates for a next step are formed from a layer of a current step by unions of all possible pairs in layer set.(elements of a layer should be sets to support this). This is also known as self-join.
Now we have filtered set of combinations of items and their respective support (support dictionary).</p>

<p>In each step we populate a support dictionary using itemsets as keys and their correspondent support as values.</p>

<h3 id="association-rules">Association rules</h3>
<p>Next step is to calculate all association rules.
Let’s fix a hyperparameters <code class="highlighter-rouge">min_confidence</code> and <code class="highlighter-rouge">min_lift</code>.</p>

<p>For all sets <code class="highlighter-rouge">L</code> in support dictionary let’s create all non-empty subsets <code class="highlighter-rouge">S</code> of <code class="highlighter-rouge">L</code>, and evaluate confidence and lift for a rule <code class="highlighter-rouge">{S -&gt; L-S}</code> and save rules, whose parameters are greater of equal then minimal.</p>

<p><em>In a notion {X -&gt; Y}, X is called from-itemset, and Y - to-itemset.</em></p>

<h2 id="apriori-tid">Apriori-TID</h2>
<ul>
  <li>the order list is not used at all for counting the support of candidate itemsets after the first pass.</li>
  <li>the candidate itemsets are generated the same way as in Apriori algorithm</li>
  <li>rules are generated the same way after support dictionary is populated
The only different is that in each layer &gt; 1 a separate list C<code class="highlighter-rouge"> is created.
C</code> hold transaction ids with correspondent itemsets from candidates on that layer that are in that particular transaction.</li>
</ul>

<p>For example, using order list from above first layer would yield such support dictionary:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>item1 0.5
item2 0.75
item3 0.75 
item5 0.75
</code></pre></div></div>
<p>Second layer candidates set is:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{item1, item2} 0.25
{item1, item3} 0.5 *
{item1, item5} 0.25
{item2, item3} 0.5 *
{item2, item5} 0.75 *
{item3, item5} 0.5 *
</code></pre></div></div>
<p>So <code class="highlighter-rouge">layer_2</code> will consist from itemsets with <code class="highlighter-rouge">*</code>. And at this step we create a separate data structure to hold transaction IDs for these sets that made it to <code class="highlighter-rouge">layer_2</code></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 {item1, item3}
2 {item2, item3} {item2, item5} {item3, item5}
3 {item1, item2} {item1, item3} {item1, item5} {item2, item3} {item2, item5} {item3, item5}
4 {item2, item5}
</code></pre></div></div>
<p>Using this additional list we will calculate support for candidates for <code class="highlighter-rouge">layer_3</code>.</p>

<h2 id="eclat">Eclat</h2>
<p>Another way to speedup support calculation is to keep a list of transaction ids for every itemset at each layer. It speeds up support calculation even more. but these transaction lists can be large in size.</p>

<p>Again using the same order list in first step, transaction ID list will be</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>item1 1, 3
item2 2, 3, 4
item3 1, 2, 3
item4 1
item5 2, 3, 4
</code></pre></div></div>
<p>item4 won’t be included in the next layer, and this list can help us to calculate lists for all possible pairs for the next step:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{item1 item2} 3
{item1 item3} 1, 3
{item1 item4} 1
{item1 item5} 3
{item2 item3} 2, 3
...etc
</code></pre></div></div>

<h2 id="fp-growth">FP-Growth</h2>
<p>This one is different from Apriori-like algorithms in a way that candidate itemsets are not generated explicitly. FP-growth uses a suffix tree (FP-tree) structure to encode transactions thus speeds up support calculation.</p>

<h2 id="tests">Tests</h2>
<p>Dataset was taken from http://archive.ics.uci.edu/ml/datasets/Online+Retail <em>Daqing Chen, Sai Liang Sain, and Kun Guo, Data mining for the online retail industry: A case study of RFM model-based customer segmentation using data mining, Journal of Database Marketing and Customer Strategy Management, Vol. 19, No. 3, pp. 197â€“208, 2012 (Published online before print: 27 August 2012. doi: 10.1057/dbm.2012.17).</em></p>

<h3 id="preprocessing">Preprocessing</h3>
<p>As each row contains <code class="highlighter-rouge">InvoiceNo</code> and <code class="highlighter-rouge">StockCode</code>, let’s group items by <code class="highlighter-rouge">InvoiceNo</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import csv
from collections import defaultdict

order_list = defaultdict(list)

with open('data.csv', encoding="iso-8859-1") as f:
    csv_reader = csv.DictReader(f)
    for row in csv_reader:
        order_list[row['InvoiceNo']].append(row['StockCode'])
</code></pre></div></div>

<p>Some stats of the dataset:</p>
<ul>
  <li>number of orders: 25900</li>
  <li>4070 items on sale</li>
  <li>minimum order: 1 item</li>
  <li>maximum order: 1114 items</li>
  <li>mean order size: ~21 items</li>
</ul>

<h3 id="python-implementation">Python implementation</h3>
<p>I’ve implemented all 4 aforementioned algorithms <a href="https://github.com/smirnov-am/pyfreqpm">here</a>. 
FP-Growth needs some more testing though, so I’ve used <a href="https://spark.apache.org/docs/2.3.0/mllib-frequent-pattern-mining.html">Apache Spark</a></p>

<p>Running times with <code class="highlighter-rouge">min_support=0.03</code>, <code class="highlighter-rouge">min_confidence=0.5</code>, <code class="highlighter-rouge">min_lift=1.0</code> are:</p>

<table>
  <thead>
    <tr>
      <th>Algorithm</th>
      <th>run time, s</th>
      <th>memmory used, MB</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>apriori-gen</td>
      <td>210</td>
      <td>50</td>
    </tr>
    <tr>
      <td>apriori-tid</td>
      <td>35</td>
      <td>202</td>
    </tr>
    <tr>
      <td>eclat</td>
      <td>*</td>
      <td>8000</td>
    </tr>
    <tr>
      <td>fp-growth</td>
      <td>8</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>* Eclat generated long id lists and it depleted 8GB RAM very fast in my docker container, so I never ended this test.</p>

<h3 id="generated-rules">Generated rules</h3>
<p>All algorithms showed same 3 rules, with 2nd and 3rd beign the same pair.</p>

<table>
  <thead>
    <tr>
      <th>from-teimset</th>
      <th>to_itemset</th>
      <th>confidence</th>
      <th>lift</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>22386</td>
      <td>85099B</td>
      <td>0.67</td>
      <td>8.2</td>
    </tr>
    <tr>
      <td>22697</td>
      <td>22699</td>
      <td>0.74</td>
      <td>17.1</td>
    </tr>
    <tr>
      <td>22699</td>
      <td>22697</td>
      <td>0.7</td>
      <td>17.1</td>
    </tr>
  </tbody>
</table>

<p>22386 = JUMBO BAG PINK POLKADOT</p>

<p>85099B = JUMBO BAG RED RETROSPOT</p>

<p>22697 = GREEN REGENCY TEACUP AND SAUCER</p>

<p>22699 = ROSES REGENCY TEACUP AND SAUCER</p>

<p>Not very impressive findings, so it worth trying to experiment with different input parameters.
But based on them we can recommend someone buying “JUMBO BAG PINK POLKADOT” to get a “JUMBO BAG RED RETROSPOT” as well. Same goes for teacups.</p>

<h2 id="another-usages-of-frequent-pattern-mining">Another usages of frequent pattern mining</h2>

<p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.300.4808&amp;rep=rep1&amp;type=pdf">Network traffic</a></p>

<p><a href="http://www.ijeert.org/pdf/v3-i10/9.pdf">Web pages</a></p>

<p><a href="https://pdfs.semanticscholar.org/5662/e754f611c34c01e3126c3df63a4ce6e78cb3.pdf">Image classification</a></p>

<p><a href="https://academic.oup.com/bib/article/16/2/216/245744">Bio informatics</a></p>


  </div><a class="u-url" href="/machine/learning,/data/mining,/python/2018/04/08/E-commerce-recommendation-systems.html" hidden></a>
</article>

      </div>
    </main></body>

</html>
